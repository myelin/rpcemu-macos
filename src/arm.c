/*RPCemu v0.6 by Tom Walker
  ARM6/7 emulation*/

#include "rpcemu.h"

#ifndef DYNAREC

#if defined WIN32 || defined _WIN32 || defined _WIN32
#include <windows.h>
#endif

int swiout=0;
int times8000=0;
/*3/12/06 - databort and prefabort have been rolled into bits 6 and 7 of armirq.
  This gives a minor speedup.
  MSR fixes from John-Mark Bell allow RISC OS 6 to work.

  31/10/06 - Various optimisations, mainly to ldmstm()
  I altered the most frequently used LDM/STM instructions to streamline the inner
  loops, which gives a 20-25% speed boost for those instructions. The most frequently
  used by far is 0x92 (STMDB !, used 5x more than any other) followed by 0x89, 0x8B,
  0x93 and 0x95.
  Also various other optimisations, eg shifts in non-S instructions are mostly inlined,
  except for those which require 'special attention', where shift amounts are outside
  the usual boundaries. Will do the same for S instructions.
  Other optimisations to memory system, !FreeDoom has gone from 24 MIPS to 31 MIPS,
  OpenTTD much the same.Desktop seems to have less gains, though Dhrystone has gone from
  40.4 DMIPS to 46 DMIPS*/
  
/*There are bits and pieces of StrongARM emulation in this file. All of the
  extra instructions have been identified, but only some of the long multiplication
  instructions have been defined (enough to get AMPlayer working in SA mode).
  Due to this, it has been defined out for now. Uncomment the following line to
  emulate what is there for now
  ArcQuake appears totally broken with this turned on, so there are obviously some
  bugs in the new instructions

  30/10/06 - Long multiplication instructions fixed, feel free to leave this in now!*/
#define STRONGARM

/*This enables the new LDR & STR instructions generated by genldr.c. On an Athlon XP
  these prove slower than the normal ones, but since they do not branch anything
  like as much they may be faster on platforms without branch prediction (eg XScale)*/
//#define NEWLDRSTR

/*Preliminary FPA emulation. This works to an extent - !Draw works with it, !SICK
  seems to (FPA Whetstone scores are around 100x without), but !AMPlayer doesn't
  work, and GCC stuff tends to crash.*/
//#define FPA

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

static int inscounts[256];

#include "config.h"

#include "hostfs.h"
#include "arm.h"
#include "cp15.h"
#include "mem.h"
#include "iomd.h"
#include "sound.h"
#include "keyboard.h"
#include "82c711.h"
#include "ide.h"

#ifdef RPCEMU_LINUX
#include "network-linux.h"
#endif

int blockend;
static int r15diff;
//static int r11check=0;
static int fdci=0;
//static int out2=0;
//static int r8match=0;
static int mmask;
int r15mask;
int memmode;
int irq;
static int cycles;
int prefabort;
//static void refillpipeline(void);
static void refillpipeline2(void);
uint32_t rotatelookup[4096];
uint32_t inscount;
int armirq=0;
int cpsr;
static uint32_t *pcpsr;
static unsigned char *pcpsrb;

uint32_t *usrregs[16];
static uint32_t userregs[17], superregs[17], fiqregs[17], irqregs[17];
static uint32_t abortregs[17], undefregs[17], systemregs[17];
static uint32_t spsr[16];
uint32_t armregs[18];
uint32_t mode;
int databort;
uint32_t opcode,opcode2,opcode3;
int prog32;


#define USER       0
#define FIQ        1
#define IRQ        2
#define SUPERVISOR 3
#define ABORT      7
#define UNDEFINED  11
#define SYSTEM     15

#define NFSET ((armregs[cpsr]&0x80000000)?1:0)
#define ZFSET ((armregs[cpsr]&0x40000000)?1:0)
#define CFSET ((armregs[cpsr]&0x20000000)?1:0)
#define VFSET ((armregs[cpsr]&0x10000000)?1:0)

#define NFLAG 0x80000000
#define ZFLAG 0x40000000
#define CFLAG 0x20000000
#define VFLAG 0x10000000
#define IFLAG 0x08000000

//int RD;
#define RD ((opcode>>12)&0xF)
#define RN ((opcode>>16)&0xF)
#define RM (opcode&0xF)

#define MULRD ((opcode>>16)&0xF)
#define MULRN ((opcode>>12)&0xF)
#define MULRS ((opcode>>8)&0xF)
#define MULRM (opcode&0xF)

#define GETADDR(r) ((r==15)?(armregs[15]&r15mask):armregs[r])
#define LOADREG(r,v) if (r==15) { armregs[15]=(armregs[15]&~r15mask)|(((v)+4)&r15mask); refillpipeline(); } else armregs[r]=(v);
#define GETREG(r) ((r==15) ? armregs[15]+4 : armregs[r])
#define LDRRESULT(a,v) ((a&3)?(v>>((a&3)<<3))|(v<<(((a&3)^3)<<3)):v)

uint32_t ins=0;

/*0=i/o, 1=all, 2=r/o, 3=os r/o, 4=super only, 5=read mem, write io*/
/*0=user, 1=os, 2=super*/
static const int modepritabler[3][6]=
{
        {0,1,1,0,0,1},
        {0,1,1,1,0,1},
        {0,1,1,1,1,1}
};
static const int modepritablew[3][6]=
{
        {0,1,0,0,0,0},
        {0,1,1,0,0,0},
        {0,1,1,1,1,0}
};

uint32_t pccache,*pccache2;

#ifdef PREFETCH
static void refillpipeline(void)
{
        uint32_t addr=(PC-4)>>2;
        if ((addr>>10)!=pccache)
        {
                pccache=addr>>10;
                pccache2=getpccache(addr<<2);
                if (pccache2==NULL)
                {
                        opcode2=opcode3=0xFFFFFFFF;
                        pccache=0xFFFFFFFF;
                        return;
                }
        }
        opcode2=pccache2[addr];
        addr++;
        if (!(addr&0x3FF))
        {
                pccache=addr>>10;
                pccache2=getpccache(addr<<2);
                if (pccache2==NULL)
                {
                        opcode3=0xFFFFFFFF;
                        pccache=0xFFFFFFFF;
                        return;
                }
        }
        opcode3=pccache2[addr];
}
#else
#define refillpipeline()
#endif

void updatemode(uint32_t m)
{
        uint32_t c,om=mode;

//        if (PC==0x8E30) output=1;
//      if (output) rpclog("Update mode to %s mode %i %08X\n",(m&0x10)?"32-bit":"26-bit",m&15,PC);
//      timetolive=1000;
//      if (!m && PC==0x9FB8) output=2;
//      if (!m && PC==0x9FBC) output=2;
        usrregs[15]=&armregs[15];
        switch (mode&15) /*Store back registers*/
        {
            case USER:
                for (c=8;c<15;c++) userregs[c]=armregs[c];
                break;

            case IRQ:
                for (c=8;c<13;c++) userregs[c]=armregs[c];
                irqregs[0]=armregs[13];
                irqregs[1]=armregs[14];
                break;

            case FIQ:
                for (c=8;c<15;c++) fiqregs[c]=armregs[c];
                break;

            case SUPERVISOR:
                for (c=8;c<13;c++) userregs[c]=armregs[c];
                superregs[0]=armregs[13];
                superregs[1]=armregs[14];
                break;

            case ABORT:
                for (c=8;c<13;c++) userregs[c]=armregs[c];
                abortregs[0]=armregs[13];
                abortregs[1]=armregs[14];
                break;

            case UNDEFINED:
                for (c=8;c<13;c++) userregs[c]=armregs[c];
                undefregs[0]=armregs[13];
                undefregs[1]=armregs[14];
                break;

            case SYSTEM:
                for (c=8;c<13;c++) userregs[c]=armregs[c];
                systemregs[0]=armregs[13];
                systemregs[1]=armregs[14];
                break;
        }
        mode=m;
        memmode=1;

        switch (m&15)
        {
            case USER:
                for (c=8;c<15;c++) armregs[c]=userregs[c];
                for (c=0;c<15;c++) usrregs[c]=&armregs[c];
                memmode=0;
                break;

            case IRQ:
                for (c=8;c<13;c++) armregs[c]=userregs[c];
                armregs[13]=irqregs[0];
                armregs[14]=irqregs[1];
                for (c=0;c<13;c++) usrregs[c]=&armregs[c];
                for (c=13;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;
            
            case FIQ:
                for (c=8;c<15;c++) armregs[c]=fiqregs[c];
                for (c=0;c<8;c++)  usrregs[c]=&armregs[c];
                for (c=8;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;

            case SUPERVISOR:
                for (c=8;c<13;c++) armregs[c]=userregs[c];
                armregs[13]=superregs[0];
                armregs[14]=superregs[1];
                for (c=0;c<13;c++) usrregs[c]=&armregs[c];
                for (c=13;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;
            
            case ABORT:
                for (c=8;c<13;c++) armregs[c]=userregs[c];
                armregs[13]=abortregs[0];
                armregs[14]=abortregs[1];
                for (c=0;c<13;c++) usrregs[c]=&armregs[c];
                for (c=13;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;

            case UNDEFINED:
                for (c=8;c<13;c++) armregs[c]=userregs[c];
                armregs[13]=undefregs[0];
                armregs[14]=undefregs[1];
                for (c=0;c<13;c++) usrregs[c]=&armregs[c];
                for (c=13;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;
 
            case SYSTEM:
                for (c=8;c<13;c++) armregs[c]=userregs[c];
                armregs[13]=systemregs[0];
                armregs[14]=systemregs[1];
                for (c=0;c<13;c++) usrregs[c]=&armregs[c];
                for (c=13;c<15;c++) usrregs[c]=&userregs[c];
                memmode=2;
                break;

            default:
                error("Bad mode %i\n",mode);
                rpclog("%i : %07X %08X %08X %08X %08X %08X %08X %08X %08X %08X %08X  %08X %08X %08X - %08X %08X %08X %i R10=%08X R11=%08X R12=%08X %08X %08X %08X %08X\n",ins,PC,armregs[0],armregs[1],armregs[2],armregs[3],armregs[4],armregs[5],armregs[6],armregs[7],armregs[8],armregs[9],armregs[12],armregs[13],armregs[14],armregs[15],armregs[16],opcode,mode,armregs[10],armregs[11],armregs[12],spsr[mode&15],armregs[16],armregs[15],armregs[14]);
                dumpregs();
                exit(-1);
        }

        if (mode&16)
        {
                mmask=31;
                cpsr=16;
                pcpsr=&armregs[16];
//                printf("Now 32-bit mode %i %08X %i\n",mode&15,PC,ins);
                r15mask=0xFFFFFFFC;
                if (!(om&16))
                {
                        armregs[16]=(armregs[15]&0xF0000000)|mode;
                        armregs[16]|=((armregs[15]&0xC000000)>>20);
                        armregs[15]&=0x3FFFFFC;
  //                      if (output) printf("Switching to 32-bit mode : CPSR %08X\n",armregs[16]);
                }
        }
        else
        {
                mmask=3;
                cpsr=15;
                pcpsr=&armregs[15];
//                printf("Now 26-bit mode %i %08X %i\n",mode&15,PC,ins);
                r15mask=0x3FFFFFC;
                armregs[16]=(armregs[16]&0xFFFFFFE0)|mode;
                if (om&16)
                {
                        armregs[15]&=r15mask;
                        armregs[15]|=(mode&3);
                        armregs[15]|=(armregs[16]&0xF0000000);
                        armregs[15]|=((armregs[16]&0xC0)<<20);
//                        printf("R15 now %08X\n",armregs[15]);
                }
        }
        pcpsrb=((unsigned char *)pcpsr)+3;
}

static int stmlookup[256];

#define countbits(c) countbitstable[c]
int countbitstable[65536];

void resetarm(void)
{
        int c,d,exec = 0,data;
//        atexit(dumpregs);
        uint32_t rotval,rotamount;
        for (c=0;c<256;c++) inscounts[c]=0;
        for (c=0;c<256;c++)
        {
                stmlookup[c]=0;
                for (d=0;d<8;d++)
                {
                        if (c&(1<<d)) stmlookup[c]+=4;
                }
        }
        for (c=0;c<65536;c++)
        {
                countbitstable[c]=0;
                for (d=0;d<16;d++)
                {
                        if (c&(1<<d)) countbitstable[c]+=4;
                }
        }
        r15mask=0x3FFFFFC;
        pccache=0xFFFFFFFF;
        updatemode(SUPERVISOR);
        cpsr=15;
//        prog32=1;
        for (c=0;c<16;c++)
        {
                for (d=0;d<16;d++)
                {
                        armregs[15]=d<<28;
                        switch (c)
                        {
                                case 0:  /*EQ*/ exec=ZFSET; break;
                                case 1:  /*NE*/ exec=!ZFSET; break;
                                case 2:  /*CS*/ exec=CFSET; break;
                                case 3:  /*CC*/ exec=!CFSET; break;
                                case 4:  /*MI*/ exec=NFSET; break;
                                case 5:  /*PL*/ exec=!NFSET; break;
                                case 6:  /*VS*/ exec=VFSET; break;
                                case 7:  /*VC*/ exec=!VFSET; break;
                                case 8:  /*HI*/ exec=(CFSET && !ZFSET); break;
                                case 9:  /*LS*/ exec=(!CFSET || ZFSET); break;
                                case 10: /*GE*/ exec=(NFSET == VFSET); break;
                                case 11: /*LT*/ exec=(NFSET != VFSET); break;
                                case 12: /*GT*/ exec=(!ZFSET && (NFSET==VFSET)); break;
                                case 13: /*LE*/ exec=(ZFSET || (NFSET!=VFSET)); break;
                                case 14: /*AL*/ exec=1; break;
                                case 15: /*NV*/ exec=0; break;
                        }
                        flaglookup[c][d]=exec;
                }
        }

        for (data=0;data<4096;data++)
        {
                rotval=data&0xFF;
                rotamount=((data>>8)&0xF)<<1;
                rotval=(rotval>>rotamount)|(rotval<<(32-rotamount));
                rotatelookup[data]=rotval;
        }

        armregs[15]=0x0C000008|3;
        armregs[16]=SUPERVISOR|0xD0;
        mode=SUPERVISOR;
        refillpipeline2();
        resetcp15();
        pccache=0xFFFFFFFF;
        if (model == CPUModel_SA110)
                r15diff = 0;
        else
                r15diff = 4;
}

int indumpregs=0;
int insnum[256];

void dumpregs(void)
{
        char s[1024];

        if (indumpregs) return;
        indumpregs=1;

        sprintf(s, "R 0=%08X R 4=%08X R 8=%08X R12=%08X\n"
                   "R 1=%08X R 5=%08X R 9=%08X R13=%08X\n"
                   "R 2=%08X R 6=%08X R10=%08X R14=%08X\n"
                   "R 3=%08X R 7=%08X R11=%08X R15=%08X\n"
                   "%u %s\n"
                   "%08X %08X %08X",
                   armregs[0], armregs[4], armregs[8], armregs[12],
                   armregs[1], armregs[5], armregs[9], armregs[13],
                   armregs[2], armregs[6], armregs[10], armregs[14],
                   armregs[3], armregs[7], armregs[11], armregs[15],
                   ins, (mmu) ? "MMU enabled" : "MMU disabled",
                   oldpc, oldpc2, oldpc3);
        rpclog("%s",s);
        printf("%s",s);

        memmode=1;

        indumpregs=0;
}

#define dumpregs()

#define checkneg(v) (v&0x80000000)
#define checkpos(v) !(v&0x80000000)

static inline void setadd(uint32_t op1, uint32_t op2, uint32_t result)
{
        uint32_t flags = 0;

        if (result == 0)                                  flags = ZFLAG;
        else if (checkneg(result))                        flags = NFLAG;
        if (result < op1)                                 flags |= CFLAG;
        if ((op1 ^ result) & (op2 ^ result) & 0x80000000) flags |= VFLAG;
        *pcpsr = ((*pcpsr) & 0x0fffffff) | flags;
}

static inline void setsub(uint32_t op1, uint32_t op2, uint32_t result)
{
        uint32_t flags = 0;

        if (result == 0)                               flags = ZFLAG;
        else if (checkneg(result))                     flags = NFLAG;
        if (result <= op1)                             flags |= CFLAG;
        if ((op1 ^ op2) & (op1 ^ result) & 0x80000000) flags |= VFLAG;
        *pcpsr = ((*pcpsr) & 0x0fffffff) | flags;
}

static inline void setsbc(uint32_t op1, uint32_t op2, uint32_t res)
{
        armregs[cpsr]&=0xFFFFFFF;
        if (!res)                           armregs[cpsr]|=ZFLAG;
        else if (checkneg(res))             armregs[cpsr]|=NFLAG;
        if ((checkneg(op1) && checkpos(op2)) ||
            (checkneg(op1) && checkpos(res)) ||
            (checkpos(op2) && checkpos(res)))  armregs[cpsr]|=CFLAG;
        if ((checkneg(op1) && checkpos(op2) && checkpos(res)) ||
            (checkpos(op1) && checkneg(op2) && checkneg(res)))
            armregs[cpsr]|=VFLAG;
}

static inline void setadc(uint32_t op1, uint32_t op2, uint32_t res)
{
        armregs[cpsr]&=0xFFFFFFF;
        if ((checkneg(op1) && checkneg(op2)) ||
            (checkneg(op1) && checkpos(res)) ||
            (checkneg(op2) && checkpos(res)))  armregs[cpsr]|=CFLAG;
        if ((checkneg(op1) && checkneg(op2) && checkpos(res)) ||
            (checkpos(op1) && checkpos(op2) && checkneg(res)))
            armregs[cpsr]|=VFLAG;
        if (!res)                          armregs[cpsr]|=ZFLAG;
        else if (checkneg(res))            armregs[cpsr]|=NFLAG;
}

static inline void setzn(uint32_t op)
{
        uint32_t flags;

        if (op == 0) {
                flags = ZFLAG;
        } else if (checkneg(op)) {
                flags = NFLAG;
        } else {
                flags = 0;
        }
        *pcpsr = flags | ((*pcpsr) & 0x3fffffff);
}

static uint32_t shift3(uint32_t opcode)
{
        uint32_t shiftmode=opcode&0x60;//(opcode>>5)&3;
        uint32_t shiftamount=(opcode>>7)&31;
        uint32_t temp;
        int cflag=CFSET;
        if (opcode&0x10)
        {
                shiftamount=armregs[(opcode>>8)&15]&0xFF;
                if (shiftmode==3)
                   shiftamount&=0x1F;
        }
        temp=armregs[RM];
        if (shiftamount) armregs[cpsr]&=~CFLAG;
        switch (shiftmode)
        {
                case 0: /*LSL*/
                if (!shiftamount) return temp;
                if (shiftamount==32)
                {
                        if (temp&1) armregs[cpsr]|=CFLAG;
                        return 0;
                }
                if (shiftamount>32) return 0;
                if ((temp<<(shiftamount-1))&0x80000000) armregs[cpsr]|=CFLAG;
                return temp<<shiftamount;

                case 0x20: /*LSR*/
                if (!shiftamount && !(opcode&0x10))
                {
                        shiftamount=32;
                }
                if (!shiftamount) return temp;
                if (shiftamount==32)
                {
                        if (temp&0x80000000) armregs[cpsr]|=CFLAG;
                        else                 armregs[cpsr]&=~CFLAG;
                        return 0;
                }
                if (shiftamount>32) return 0;
                if ((temp>>(shiftamount-1))&1) armregs[cpsr]|=CFLAG;
                return temp>>shiftamount;

                case 0x40: /*ASR*/
                if (!shiftamount)
                {
                        if (opcode&0x10) return temp;
                }
                if (shiftamount>=32 || !shiftamount)
                {
                        if (temp&0x80000000) armregs[cpsr]|=CFLAG;
                        else                 armregs[cpsr]&=~CFLAG;
                        if (temp&0x80000000) return 0xFFFFFFFF;
                        return 0;
                }
                if (((int)temp>>(shiftamount-1))&1) armregs[cpsr]|=CFLAG;
                return (int)temp>>shiftamount;

                default: /*ROR*/
                armregs[cpsr]&=~CFLAG;
                if (!shiftamount && !(opcode&0x10))
                {
                        if (temp&1) armregs[cpsr]|=CFLAG;
                        return (((cflag)?1:0)<<31)|(temp>>1);
                }
                if (!shiftamount)
                {
                        armregs[cpsr]|=cflag;
                        return temp;
                }
                if (!(shiftamount&0x1F))
                {
                        if (temp&0x80000000) armregs[cpsr]|=CFLAG;
                        return temp;
                }
                if (((temp>>shiftamount)|(temp<<(32-shiftamount)))&0x80000000) armregs[cpsr]|=CFLAG;
                return (temp>>shiftamount)|(temp<<(32-shiftamount));
                break;
        }
}

#define shift(o)  ((o&0xFF0)?shift3(o):armregs[RM])
#define shift2(o) ((o&0xFF0)?shift4(o):armregs[RM])
#define shift_ldrstr(o) shift2(o)
//#define shift_ldrstr(o) ((o&0xFF0)?shift_ldrstr2(o):armregs[RM])

//#if 0
static unsigned
shift5(unsigned opcode, unsigned shiftmode, unsigned shiftamount, uint32_t rm)
{
                switch (shiftmode)
                {
                        case 0: /*LSL*/
                        if (!shiftamount)    return rm;
                        return 0; /*shiftamount>=32*/

                        case 0x20: /*LSR*/
                        if (!shiftamount && (opcode&0x10)) return rm;
                        return 0; /*shiftamount>=32*/

                        case 0x40: /*ASR*/
                        if (!shiftamount && !(opcode&0x10)) shiftamount=32;
                        if (shiftamount>=32)
                        {
                                if (rm&0x80000000)
                                   return 0xFFFFFFFF;
                                return 0;
                        }
                        return (int)rm>>shiftamount;

                        case 0x60: /*ROR*/
                        if (!(opcode&0x10)) return (((CFSET)?1:0)<<31)|(rm>>1);
                        shiftamount&=0x1F;
                        return (rm>>shiftamount)|(rm<<(32-shiftamount));

                        default:
                        error("Shift2 mode %u amount %u\n", shiftmode, shiftamount);
                        dumpregs();
                        exit(-1);
                }
}
//#endif

static inline unsigned shift4(unsigned opcode)
{
        unsigned shiftmode=opcode&0x60;
        unsigned shiftamount=(opcode&0x10)?(armregs[(opcode>>8)&15]&0xFF):((opcode>>7)&31);
        uint32_t rm=armregs[RM];
        if ((shiftamount-1)>=31)
        {
                return shift5(opcode,shiftmode,shiftamount,rm);
        }
        else
        {
                switch (shiftmode)
                {
                        case 0: /*LSL*/
                        return rm<<shiftamount;
                        case 0x20: /*LSR*/
                        return rm>>shiftamount;
                        case 0x40: /*ASR*/
                        return (int)rm>>shiftamount;
                        default: /*ROR*/
                        return (rm>>shiftamount)|(rm<<(32-shiftamount));
                }
        }
}
#if 0
unsigned shift_ldrstr3(unsigned opcode, unsigned shiftmode, unsigned shiftamount, uint32_t rm)
{
                switch (shiftmode)
                {
                        case 0: /*LSL*/
                        return rm;
                        case 0x20: /*LSR*/
                        return 0;
                        case 0x40: /*ASR*/
                        if (rm&0x80000000) return 0xFFFFFFFF;
                        return 0;
                        default: /*ROR*/
                        return (((*pcpsr)/*armregs[cpsr]*/&CFLAG)<<2)|(rm>>1);
//                        return (((CFSET)?1:0)<<31)|(rm>>1);
                }
}

static inline unsigned shift_ldrstr2(unsigned opcode)
{
        unsigned shiftmode=opcode&0x60;
        unsigned shiftamount=(opcode>>7)&31;
        uint32_t rm=armregs[RM];
        if (!shiftamount)
        {
                return 0;
//                shift_ldrstr3(opcode,shiftmode,shiftamount,rm);
        }
        else
        {
                switch (shiftmode)
                {
                        case 0: /*LSL*/
                        return rm<<shiftamount;
                        case 0x20: /*LSR*/
                        return rm>>shiftamount;
                        case 0x40: /*ASR*/
                        return (int)rm>>shiftamount;
                        default: /*ROR*/
                        return (rm>>shiftamount)|(rm<<(32-shiftamount));
                }
        }
}
#endif
static inline unsigned rotate(unsigned data)
{
        uint32_t rotval;
        rotval=rotatelookup[data&4095];
        if (/*data&0x100000 && */data&0xF00)
        {
//                (*pcpsrb)=((*pcpsrb)&~(CFLAG>>24))|(((rotval>>2)&CFLAG)>>24);
//                /*armregs[cpsr]*/(*pcpsrb)&=~(CFLAG>>24);
//                /*armregs[cpsr]*/(*pcpsrb)|=(((rotval>>2)&CFLAG)>>24);
                if (rotval&0x80000000) armregs[cpsr]|=CFLAG;
                else                   armregs[cpsr]&=~CFLAG;
        }
        return rotval;
}

#define rotate2(v) rotatelookup[v&4095]
static const int ldrlookup[4]={0,8,16,24};

#define ldrresult(v,a) ((v>>ldrlookup[addr&3])|(v<<(32-ldrlookup[addr&3])))

#define undefined() exception(UNDEFINED,8,4)

static void refillpipeline2()
{
        #ifdef PREFETCH
        uint32_t addr=PC-8;
        if ((addr>>12)!=pccache)
        {
                pccache=addr>>12;
                pccache2=getpccache(addr);
                if (pccache2==NULL)
                {
                        opcode2=opcode3=0xFFFFFFFF;
                        pccache=0xFFFFFFFF;
                        return;
                }
        }
        opcode2=pccache2[addr>>2];
        addr+=4;
        if ((addr>>12)!=pccache)
        {
                pccache=addr>>12;
                pccache2=getpccache(addr);
                if (pccache2==NULL)
                {
                        opcode3=0xFFFFFFFF;
                        pccache=0xFFFFFFFF;
                        return;
                }
        }
        opcode3=pccache2[addr>>2];
//        opcode2=readmeml(PC-8);
//        opcode3=readmeml(PC-4);
        #endif
}

static const uint32_t msrlookup[16]=
{
        0x00000000,0x000000FF,0x0000FF00,0x0000FFFF,
        0x00FF0000,0x00FF00FF,0x00FFFF00,0x00FFFFFF,
        0xFF000000,0xFF0000FF,0xFF00FF00,0xFF00FFFF,
        0xFFFF0000,0xFFFF00FF,0xFFFFFF00,0xFFFFFFFF
};

static void bad_opcode(uint32_t opcode) 
{
     error("Bad opcode %02X %08X at %07X\n",(opcode >> 20) & 0xFF, opcode, PC);
     rpclog("Bad opcode %02X %08X at %07X\n",(opcode >> 20) & 0xFF, opcode, PC);
     dumpregs();
     exit(EXIT_FAILURE);
}

void exception(int mmode, uint32_t address, int diff)
{
        uint32_t templ;
        unsigned char irq=0xC0;
        if (mmode==SUPERVISOR) irq=0x80;
        if (mode&16)
        {
                templ=armregs[15]-diff;
                spsr[mmode]=armregs[16];
                updatemode(mmode|16);
                armregs[14]=templ;
                armregs[16]&=~0x1F;
                armregs[16]|=0x10|mmode|irq;
                armregs[15]=address;
                refillpipeline();
        }
        else if (prog32)
        {
                templ=armregs[15]-diff;
                updatemode(mmode|16);
                armregs[14]=templ&0x3FFFFFC;
                spsr[mmode]=(armregs[16]&~0x1F)|(templ&3);
                spsr[mmode]&=~0x10;
                armregs[16]|=irq;
                armregs[15]=address;
                refillpipeline();
        }
        else
        {
                templ=armregs[15]-diff;
                armregs[15]|=3;
                updatemode(SUPERVISOR);
                armregs[14]=templ;
                armregs[15]&=0xFC000003;
                armregs[15]|=((irq<<20)|address);
                refillpipeline();
        }
}
#if 0
#define writememfast(a,v) writememl(a,v)
//#define writememfast(a,v) if (((a)&0xFFFFF000)==raddrl[((a)>>12)&0xFF]) raddrl2[((a)>>12)&0xFF][(a)>>2]=v; else writememl(a,v)
//#define writememfast(a,v) if (((a)&0xFFFFF000)!=raddrl[((a)>>12)&0xFF]) { readmeml(a); } raddrl2[((a)>>12)&0xFF][(a)>>2]=v
static inline void ldmstm(uint32_t ls_opcode, uint32_t opcode)
{
  uint32_t templ, mask, addr, c;
  uint32_t *rn;
//                                inscounts[(opcode>>20)&0xFF]++;
  //  addr = mem_getphys(armregs[RN]);
  addr = armregs[RN];
  switch (ls_opcode) 
    {

    case 0x80: /*STMDA*/
    mask=0x8000;
    for (c=15;c<16;c--)
    {
            if (opcode&mask)
            {
                    if (c==15) { writememl(addr,armregs[c]+r15diff); }
                    else       { writememl(addr,armregs[c]); }
                    addr-=4;
//                    cycles--;
            }
            mask>>=1;
    }
//    cycles-=2;
    break;

    case 0x82: /*STMDA !*/
        rn=&armregs[RN];
        templ=stmlookup[opcode&0xFF]+stmlookup[(opcode>>8)&0xFF];
        c=15;
        while (!(opcode&0x8000))
        {
                opcode<<=1;
                c--;
        }
        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
        else       { writememfast(addr,armregs[c]); }
        addr-=4;
        c--;
        *rn-=templ;
        for (c;c<16;c--)
        {
                if (opcode&0x4000)
                {
                        writememfast(addr,armregs[c]);
                        addr-=4;
                }
                opcode<<=1;
        }
    break;
                                
    case 0x83: /*LDMDA !*/
    if (!(opcode&(1<<RN)))
    {
            mask=0x8000;
            for (c=15;c<16;c--)
            {
                    if (opcode&mask)
                    {
                            if (c==15) armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                            else       armregs[c]=readmeml(addr);
                            addr-=4;
                            armregs[RN]-=4;
//                            cycles--;
                    }
                    mask>>=1;
            }
            if (opcode&0x8000) refillpipeline();
//            cycles-=3;
            return;
    }
    case 0x81: /*LDMDA*/
    mask=0x8000;
    for (c=15;c<16;c--)
    {
            if (opcode&mask)
            {
                    if (c==15) armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                    else       armregs[c]=readmeml(addr);
                    addr-=4;
//                    //cycles--;
            }
            mask>>=1;
    }
    if (opcode&0x8000) refillpipeline();
//    //cycles-=3;
    break;


    case 0x85: /*LDMDA ^*/
    mask=0x8000;
    if (opcode&0x8000)
    {
            for (c=15;c<16;c--)
            {
                    if (opcode&mask)
                    {
                            if (c==15 && !(armregs[15]&3) && !(mode&16))
                               armregs[15]=(readmeml(addr)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                            else
                               armregs[c]=readmeml(addr);
                            if (c==15 && (mode&16)) armregs[cpsr]=spsr[mode&15];
                            addr-=4;
//                            //cycles--;
                    }
                    mask>>=1;
            }
            armregs[15]+=4;
            if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
            refillpipeline();
    }
    else
    {
            for (c=15;c<16;c--)
            {
                    if (opcode&mask)
                    {
                            *usrregs[c]=readmeml(addr);
                            addr-=4;
  //                          //cycles--;
                    }
                    mask>>=1;
            }
    }
//    //cycles-=3;
    break;

    case 0x88: /*STMIA*/
    mask=1;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    if (c==15) { writememl(addr,armregs[c]+r15diff); }
                    else       { writememl(addr,armregs[c]); }
                    addr+=4;
//                    //cycles--;
            }
            mask<<=1;
    }
//    //cycles-=2;
    break;


    case 0x8A: /*STMIA !*/
        rn=&armregs[RN];
        templ=stmlookup[opcode&0xFF]+stmlookup[(opcode>>8)&0xFF];
        c=0;
        while (!(opcode&1))
        {
                opcode>>=1;
                c++;
        }
        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
        else       { writememfast(addr,armregs[c]); }
        addr+=4;
        c++;
        *rn+=templ;
        for (;c<16;c++)
        {
                if (opcode&2)
                {
                        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
                        else       { writememfast(addr,armregs[c]); }
                        addr+=4;
                }
                opcode>>=1;
        }
        break;

        case 0x8B: /*LDMIA !*/
        if (!(opcode&(1<<RN)))
        {
                templ=RN;
                for (c=0;c<15;c++)
                {
                        if (opcode&1)
                        {
                                armregs[c]=readmeml(addr);
                                addr+=4;
                        }
                        opcode>>=1;
                }
                if (opcode&1)
                {
                        armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                        addr+=4;
                        refillpipeline();
                }
                armregs[templ]=addr;
                return;
        }
        case 0x89: /*LDMIA*/
        for (c=0;c<15;c++)
        {
                if (opcode & 1)
                {
                        armregs[c]=readmeml(addr);
                        addr+=4;
                }
                opcode>>=1;
        }
        if (opcode&1)
        {
	       armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
	       refillpipeline();
        }
        break;
                                
    case 0x8C: /*STMIA ^*/
    mask=1;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    if (c==15) { writememl(addr,*usrregs[c]+r15diff); }
                    else       { writememl(addr,*usrregs[c]); }
                    addr+=4;
//                    //cycles--;
            }
            mask<<=1;
    }
//    //cycles-=2;
    break;

    case 0x8D: /*LDMIA ^*/
    mask=1;
    if (opcode&0x8000)
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            if (c==15 && !(armregs[15]&3) && !(mode&16))
                               armregs[15]=(readmeml(addr)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                            else
                               armregs[c]=readmeml(addr);
                            if (c==15 && (mode&16)) armregs[cpsr]=spsr[mode&15];
                            addr+=4;
//                            //cycles--;
                    }
                    mask<<=1;
            }
            armregs[15]+=4;
            if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
            refillpipeline();
    }
    else
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            *usrregs[c]=readmeml(addr);
                            addr+=4;
//                            //cycles--;
                    }
                    mask<<=1;
            }
    }
//    //cycles-=3;
    break;

    case 0x8F: /*LDMIA !^*/
    mask=1;
    if (opcode&0x8000)
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            if (c==15 && !(armregs[15]&3) && !(mode&16))
                               armregs[15]=(readmeml(addr)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                            else
                               armregs[c]=readmeml(addr);
                            if (c==15 && (mode&16)) armregs[cpsr]=spsr[mode&15];
                            addr+=4;
                            armregs[RN]+=4;
//                            //cycles--;
                    }
                    mask<<=1;
            }
            armregs[15]+=4;
            if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
            refillpipeline();
    }
    else
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            *usrregs[c]=readmeml(addr);
                            addr+=4;
                            armregs[RN]+=4;
//                            //cycles--;
                    }
                    mask<<=1;
            }
    }
//    //cycles-=3;
    break;

    case 0x90: /*STMDB*/
    mask=0x8000;
    for (c=15;c<16;c--)
    {
            if (opcode&mask)
            {
                    addr-=4;
                    if (c==15) { writememl(addr,armregs[c]+r15diff); }
                    else       { writememl(addr,armregs[c]); }
//                    //cycles--;
            }
            mask>>=1;
    }
//    //cycles-=2;
    break;

        case 0x92: /*STMDB !*/
        rn=&armregs[RN];
        templ=stmlookup[opcode&0xFF]+stmlookup[(opcode>>8)&0xFF];
        c=15;
        while (!(opcode&0x8000))
        {
                opcode<<=1;
                c--;
        }
        addr-=4;
        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
        else       { writememfast(addr,armregs[c]); }
        c--;
        *rn-=templ;
        for (c;c<16;c--)
        {
                if (opcode&0x4000)
                {
                        addr-=4;
                        writememfast(addr,armregs[c]);
                }
                opcode<<=1;
        }
        break;

        case 0x93: /*LDMDB !*/
        if (!(opcode&(1<<RN)))
        {
                templ=RN;
                if (opcode&0x8000)
                {
                        addr-=4;
                        armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                        refillpipeline();
                }
                for (c=14;c<16;c--)
                {
                        if (opcode&0x4000)
                        {
                                addr-=4;
                                armregs[c]=readmeml(addr);
                        }
                        opcode<<=1;
                }
                armregs[templ]=addr;
                return;
        }
        case 0x91: /*LDMDB*/
        if (opcode&0x8000)
        {
                addr-=4;
                armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                refillpipeline();
        }
        for (c=14;c<16;c--)
        {
                if (opcode&0x4000)
                {
                        addr-=4;
                        armregs[c]=readmeml(addr);
                }
                opcode<<=1;
        }
        break;

    case 0x94: /*STMDB ^*/
    mask=0x8000;
    for (c=15;c<16;c--)
    {
            if (opcode&mask)
            {
                    addr-=4;
                    if (c==15) { writememl(addr,*usrregs[c]+r15diff); }
                    else       { writememl(addr,*usrregs[c]); }
//                    //cycles--;
            }
            mask>>=1;
    }
//    //cycles-=2;
    break;

        case 0x95: /*LDMDB ^*/
        mask=0x8000;
        if (opcode&0x8000)
        {
                addr-=4;
                if (!mode) armregs[15]=(readmeml(addr)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                else       armregs[15]=readmeml(addr);
                if (mode&16)
                {
                        armregs[cpsr]=spsr[mode&15];
                        if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                }
                for (c=14;c<16;c--)
                {
                        if (opcode&0x4000)
                        {
                                addr-=4;
                                armregs[c]=readmeml(addr);
                        }
                        opcode<<=1;
                }
                armregs[15]+=4;
                refillpipeline();
        }
        else
        {
                for (c=14;c<16;c--)
                {
                        if (opcode&0x4000)
                        {
                                addr-=4;
                                *usrregs[c]=readmeml(addr);
                        }
                        opcode<<=1;
                }
        }
        break;

    case 0x96: /*STMDB !^*/
    mask=0x8000;
    templ=0;
    for (c=15;c<16;c--)
    {
            if (opcode&mask)
            {
                    addr-=4;
                    armregs[RN]-=4;
                    if (c==15)                { writememl(addr,*usrregs[c]+r15diff); }
                    else if (c==RN && !templ) { writememl(addr,*usrregs[c]+4); }
                    else                      { writememl(addr,*usrregs[c]); }
//                    //cycles--;
            }
            mask>>=1;
    }
//    //cycles-=2;
    break;
    case 0x98: /*STMIB*/
    mask=1;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    addr+=4;
                    if (c==15) { writememl(addr,armregs[c]+r15diff); }
                    else       { writememl(addr,armregs[c]); }
//                    //cycles--;
            }
            mask<<=1;
    }
//    //cycles-=2;
    break;
 
    case 0x9A: /*STMIB !*/
        rn=&armregs[RN];
        templ=stmlookup[opcode&0xFF]+stmlookup[(opcode>>8)&0xFF];
        c=0;
        while (!(opcode&1))
        {
                opcode>>=1;
                c++;
        }
        addr+=4;
        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
        else       { writememfast(addr,armregs[c]); }
        c++;
        *rn+=templ;
        for (;c<16;c++)
        {
                if (opcode&2)
                {
                        addr+=4;
                        if (c==15) { writememfast(addr,armregs[15]+r15diff); }
                        else       { writememfast(addr,armregs[c]); }
                }
                opcode>>=1;
        }
/*    mask=1;
    templ=0;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    addr+=4;
                    armregs[RN]+=4;
                    if (c==15)                { writememl(addr,armregs[c]+r15diff); }
                    else if (c==RN && !templ) { writememl(addr,armregs[c]-4); }
                    else                      { writememl(addr,armregs[c]); }
//                    //cycles--;
            }
            mask<<=1;
    }*/
//    //cycles-=2;
    break;

    case 0x9B: /*LDMIB !*/
    if (!(opcode&(1<<RN)))
    {
            mask=1;
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            addr+=4;
                            armregs[RN]+=4;
                            if (c==15) armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                            else       armregs[c]=readmeml(addr);
//                            //cycles--;
                    }
                    mask<<=1;
            }
            if (opcode&0x8000) refillpipeline();
//            //cycles-=3;
            return;
    }
    case 0x99: /*LDMIB*/
    mask=1;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    addr+=4;
                    if (c==15) armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask);
                    else       armregs[c]=readmeml(addr);
//                    //cycles--;
            }
            mask<<=1;
    }
    if (opcode&0x8000) refillpipeline();
//    //cycles-=3;
    break;
    case 0x9C: /*STMIB ^*/
    mask=1;
    for (c=0;c<16;c++)
    {
            if (opcode&mask)
            {
                    addr+=4;
                    if (c==15) { writememl(addr,*usrregs[c]+r15diff); }
                    else       { writememl(addr,*usrregs[c]); }
//                    //cycles--;
            }
            mask<<=1;
    }
//    //cycles-=2;
    break;

    case 0x9D: /*LDMIB ^*/
    mask=1;
    if (opcode&0x8000)
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            addr+=4;
                            if (c==15 && !(armregs[15]&3) && !(mode&16))
                               armregs[15]=(readmeml(addr)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                            else
                               armregs[c]=readmeml(addr);
                            if (c==15 && (mode&16)) armregs[cpsr]=spsr[mode&15];
//                            //cycles--;
                    }
                    mask<<=1;
            }
            armregs[15]+=4;
            if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
            refillpipeline();
    }
    else
    {
            for (c=0;c<16;c++)
            {
                    if (opcode&mask)
                    {
                            addr+=4;
                            *usrregs[c]=readmeml(addr);
//                            //cycles--;
                    }
                    mask<<=1;
            }
    }
//    //cycles-=3;
    break;


    }
}
#endif
void execarm(int cycs)
{
        int linecyc;
        int target;
        int c;
        uint32_t templ,templ2,addr,addr2,mask;
        unsigned char temp;
//        int RD;
        cycles+=cycs;
        while (cycles>0)
        {
//                cyccount+=200;
//                linecyc=200;
//                while (linecyc>0)
                for (linecyc=0;linecyc<200;linecyc++)
                {
/*                        oldpc3=oldpc2;
                        oldpc2=oldpc;
                        oldpc=PC;*/
#ifdef PREFETCH
                        opcode=opcode2;
                        opcode2=opcode3;
#endif
                        if ((PC>>12)!=pccache)
                        {
                                pccache=PC>>12;
                                pccache2=getpccache(PC);
                                if (pccache2==NULL) opcode=pccache=0xFFFFFFFF;
#ifdef PREFETCH
                                else                      opcode3=pccache2[PC>>2];
#else
                                else                      opcode=pccache2[PC>>2];
#endif
                        }
                        else
#ifdef PREFETCH
                           opcode3=pccache2[PC>>2];
#else
                           opcode=pccache2[PC>>2];
#endif
                        target=(opcode>>20)&0xFF;
                        if (flaglookup[opcode>>28][(*pcpsr)>>28] && !(armirq&0x80))//prefabort)
                        {
//                                inscounts[(opcode>>20)&0xFF]++;
#ifdef STRONGARM
//                                if ((opcode&0xE000090)==0x90)
//                                {
                                if ((opcode&0xE0000F0)==0xB0) /*LDRH/STRH*/
                                {
                                        error("Bad LDRH/STRH opcode %08X\n",opcode);
                                        dumpregs();
                                        exit(-1);
                                }
                                else if ((opcode&0xE1000D0)==0x1000D0) /*LDRS*/
                                {
                                        error("Bad LDRH/STRH opcode %08X\n",opcode);
                                        dumpregs();
                                        exit(-1);
//                                }
//                                goto domain;
                                }
                                else
                                {
//                                        domain:
//                                        GETRD;
#endif
                                switch (target)//((opcode>>20)&0xFF)
                                {
				        case 0x00: /*AND reg*/
				  /*    if (!opcode)
					{
					      printf("Opcode 0 at %08X\n",PC);
					      dumpregs();
					      exit(-1);
					}*/
					if (((opcode&0xE00090)==0x90)) /*MUL*/
					{
					      armregs[MULRD]=(armregs[MULRM])*(armregs[MULRS]);
					      if (MULRD==MULRM) armregs[MULRD]=0;
					      //cycles-=17;
					}
					else
					{
					      templ=shift2(opcode);
					      if (RD==15)
					      {
						     armregs[15]=(((GETADDR(RN)&templ)+4)&r15mask)|(armregs[15]&~r15mask);
						     refillpipeline();
					      }
					      else
					      {
						     armregs[RD]=GETADDR(RN)&templ;
					      }
					      //cycles--;
					}
					break;

				        case 0x01: /*ANDS reg*/
					if (((opcode&0xE000090)==0x90)) /*MULS*/
					{
					        armregs[MULRD]=(armregs[MULRM])*(armregs[MULRS]);
					        if (MULRD==MULRM) armregs[MULRD]=0;
					        setzn(armregs[MULRD]);
					       //cycles-=17;
					}
					else
					{
					       if (RD==15)
					       {
						       templ=shift2(opcode);
						       armregs[15]=(GETADDR(RN)&templ)+4;
						       refillpipeline();
					               if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
					       }
					       else
					       {
						       templ=shift(opcode);
						       armregs[RD]=GETADDR(RN)&templ;
						       setzn(armregs[RD]);
					       }
					       //cycles--;
					}
					break;

				        case 0x02: /*EOR reg*/
					if (((opcode&0xE000090)==0x90)) /*MLA*/
					{
					       armregs[MULRD]=((armregs[MULRM])*(armregs[MULRS]))+armregs[MULRN];
					       if (MULRD==MULRM) armregs[MULRD]=0;
					       //cycles-=17;
					}
					else
					{
					       templ=shift2(opcode);
					       if (RD==15)
					       {
						      armregs[15]=(((GETADDR(RN)^templ)+4)&r15mask)|(armregs[15]&~r15mask);
						      refillpipeline();
					       }
					       else
					       {
						      armregs[RD]=GETADDR(RN)^templ;
					       }
					       //cycles--;
                                        }
                                        break;

                                        case 0x03: /*EORS reg*/
                                        if (((opcode&0xE000090)==0x90)) /*MLAS*/
                                        {
                                                armregs[MULRD]=((armregs[MULRM])*(armregs[MULRS]))+armregs[MULRN];
					        if (MULRD==MULRM) armregs[MULRD]=0;
                                                setzn(armregs[MULRD]);
                                                //cycles-=17;
                                        }
                                        else
                                        {
                                                if (RD==15)
                                                {
                                                        templ=shift2(opcode);
                                                        armregs[15]=(GETADDR(RN)^templ)+4;
                                                        refillpipeline();
                                                        if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                                }
                                                else
                                                {
                                                        templ=shift(opcode);
                                                        armregs[RD]=GETADDR(RN)^templ;
                                                        setzn(armregs[RD]);
                                                }
                                                //cycles--;
                                        }
                                        break;

                                        case 0x04: /*SUB reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)-templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)-templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x05: /*SUBS reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(GETADDR(RN)-templ)+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsub(GETADDR(RN),templ,GETADDR(RN)-templ);
                                                armregs[RD]=GETADDR(RN)-templ;
                                        }
                                        //cycles--;
                                        break;

                                        case 0x06: /*RSB reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((templ-GETADDR(RN))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=templ-GETADDR(RN);
                                        }
                                        //cycles--;
                                        break;
                                        case 0x07: /*RSBS reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(templ-GETADDR(RN))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsub(templ,GETADDR(RN),templ-GETADDR(RN));
                                                armregs[RD]=templ-GETADDR(RN);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x08: /*ADD reg*/
                                #ifdef STRONGARM
					if ((opcode&0x90)==0x90) /*MULL*/
					{
                                                uint64_t mula,mulb,mulres;
                                                mula=(uint64_t)(uint32_t)armregs[MULRS];
                                                mulb=(uint64_t)(uint32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                        }
                                        else
                                        {
                                #endif
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=((GETADDR(RN)+templ+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)+templ;
                                        }
                                        //cycles--;
                                #ifdef STRONGARM
                                        }
                                #endif
                                        break;
                                        case 0x09: /*ADDS reg*/
                                #ifdef STRONGARM
					if (((opcode&0x90)==0x90)) /*MULLS*/
					{
                                                uint64_t mula,mulb,mulres;
                                                mula=(uint64_t)(uint32_t)armregs[MULRS];
                                                mulb=(uint64_t)(uint32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                armregs[cpsr]&=~0xC0000000;
                                                if (!(armregs[MULRN]|armregs[MULRD])) armregs[cpsr]|=ZFLAG;
                                                if (armregs[MULRD]&0x80000000) armregs[cpsr]|=NFLAG;
                                        }
                                        else
                                        {
                                #endif
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
        //                                        printf("R15=%08X+%08X+4=",GETADDR(RN),templ);
                                                armregs[15]=GETADDR(RN)+templ+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
        //                                        printf("%08X\n",armregs[15]);
                                        }
                                        else
                                        {
                                                setadd(GETADDR(RN),templ,GETADDR(RN)+templ);
        //                                        printf("ADDS %08X+%08X = ",GETADDR(RN),templ);
                                                armregs[RD]=GETADDR(RN)+templ;
        //                                        printf("%08X\n",armregs[RD]);
        //                                        setzn(templ);
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                                                                
                                        }
                                #endif
                                        break;
                                
                                        case 0x0A: /*ADC reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*UMLAL*/
					{
                                                uint64_t mula,mulb,mulres;
                                                uint32_t addr,addr2;
                                                addr=armregs[MULRN];
                                                addr2=armregs[MULRD];
                                                mula=(uint64_t)(uint32_t)armregs[MULRS];
                                                mulb=(uint64_t)(uint32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                if ((armregs[MULRN]+addr)<armregs[MULRN]) armregs[MULRD]++;
                                                armregs[MULRN]+=addr;
                                                armregs[MULRD]+=addr2;
                                        }
                                        else
                                        {
                                #endif
                                        templ2=CFSET;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=((GETADDR(RN)+templ+templ2+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)+templ+templ2;
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;
                                        case 0x0B: /*ADCS reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*UMLALS*/
					{
                                                uint64_t mula,mulb,mulres;
                                                uint32_t addr,addr2;
                                                addr=armregs[MULRN];
                                                addr2=armregs[MULRD];
                                                mula=(uint64_t)(uint32_t)armregs[MULRS];
                                                mulb=(uint64_t)(uint32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                if ((armregs[MULRN]+addr)<armregs[MULRN]) armregs[MULRD]++;
                                                armregs[MULRN]+=addr;
                                                armregs[MULRD]+=addr2;
                                                armregs[cpsr]&=~0xC0000000;
                                                if (!(armregs[MULRN]|armregs[MULRD])) armregs[cpsr]|=ZFLAG;
                                                if (armregs[MULRD]&0x80000000) armregs[cpsr]|=NFLAG;
                                        }
                                        else
                                        {
                                #endif                                                
                                        templ2=CFSET;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=GETADDR(RN)+templ+templ2+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setadc(GETADDR(RN),templ,GETADDR(RN)+templ+templ2);
                                                armregs[RD]=GETADDR(RN)+templ+templ2;
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;

                                        case 0x0C: /*SBC reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*SMULL*/
					{
                                                int64_t mula,mulb,mulres;
                                                mula=(int64_t)(int32_t)armregs[MULRS];
                                                mulb=(int64_t)(int32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                        }
                                        else
                                        {
                                #endif
                                        templ2=(CFSET)?0:1;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)-(templ+templ2))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)-(templ+templ2);
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;
                                        case 0x0D: /*SBCS reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*SMULLS*/
					{
                                                int64_t mula,mulb,mulres;
                                                mula=(int64_t)(int32_t)armregs[MULRS];
                                                mulb=(int64_t)(int32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                armregs[cpsr]&=~0xC0000000;
                                                if (!(armregs[MULRN]|armregs[MULRD])) armregs[cpsr]|=ZFLAG;
                                                if (armregs[MULRD]&0x80000000) armregs[cpsr]|=NFLAG;
                                        }
                                        else
                                        {
                                #endif
                                        templ2=(CFSET)?0:1;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(GETADDR(RN)-(templ+templ2))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsbc(GETADDR(RN),templ,GETADDR(RN)-(templ+templ2));
                                                armregs[RD]=GETADDR(RN)-(templ+templ2);
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;
                                        case 0x0E: /*RSC reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*SMLAL*/
					{
                                                int64_t mula,mulb,mulres;
                                                addr=armregs[MULRN];
                                                addr2=armregs[MULRD];
                                                mula=(int64_t)(int32_t)armregs[MULRS];
                                                mulb=(int64_t)(int32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                if ((armregs[MULRN]+addr)<armregs[MULRN]) armregs[MULRD]++;
                                                armregs[MULRN]+=addr;
                                                armregs[MULRD]+=addr2;
                                        }
                                        else
                                        {
                                #endif
                                        templ2=(CFSET)?0:1;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((templ-(GETADDR(RN)+templ2))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=templ-(GETADDR(RN)+templ2);
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;
                                        case 0x0F: /*RSCS reg*/
                                #ifdef STRONGARM
					if (((opcode&0xE000090)==0x000090)) /*Long MUL*/
					{
                                                int64_t mula,mulb,mulres;
                                                addr=armregs[MULRN];
                                                addr2=armregs[MULRD];
                                                mula=(int64_t)(int32_t)armregs[MULRS];
                                                mulb=(int64_t)(int32_t)armregs[MULRM];
                                                mulres=mula*mulb;
                                                armregs[MULRN]=mulres&0xFFFFFFFF;
                                                armregs[MULRD]=mulres>>32;
                                                if ((armregs[MULRN]+addr)<armregs[MULRN]) armregs[MULRD]++;
                                                armregs[MULRN]+=addr;
                                                armregs[MULRD]+=addr2;
                                                armregs[cpsr]&=~0xC0000000;
                                                if (!(armregs[MULRN]|armregs[MULRD])) armregs[cpsr]|=ZFLAG;
                                                if (armregs[MULRD]&0x80000000) armregs[cpsr]|=NFLAG;
                                        }
                                        else
                                        {
                                #endif
                                        templ2=(CFSET)?0:1;
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(templ-(GETADDR(RN)+templ2))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsbc(templ,GETADDR(RN),templ-(GETADDR(RN)+templ2));
                                                armregs[RD]=templ-(GETADDR(RN)+templ2);
                                        }
                                        //cycles--;
                                #ifdef STRONGARM                                        
                                        }
                                #endif
                                        break;

                                        case 0x10: /*SWP word*/
                                        if ((opcode&0xF0)==0x90)
                                        {
                                                addr=armregs[RN];
                                                templ=GETREG(RM);
                                                LOADREG(RD,readmeml(addr));
                                                writememl(addr,templ);
                                                //cycles-=3;
                                        }
                                        else if (!(opcode&0xFFF)) /*MRS CPSR*/
                                        {
                                                if (!(mode&16))
                                                {
                                                        armregs[16]=(armregs[15]&0xF0000000)|(armregs[15]&3);
                                                        armregs[16]|=((armregs[15]&0xC000000)>>20);
//                                                        if (output) rpclo("CPSR %08X R15 %08X\n",armregs[16],armregs[15]);
                                                }
                                                armregs[RD]=armregs[16];
                                        }
                                        else
                                        {
                                                undefined();
//					        bad_opcode(opcode);
                                        }
                                        break;
                                        
                                        case 0x11: /*TST reg*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                templ=armregs[15]&0x3FFFFFC;
                                                armregs[15]=((GETADDR(RN)&shift2(opcode))&0xFC000003)|templ;
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setzn(GETADDR(RN)&shift(opcode));
                                        }
                                        //cycles--;
                                        break;

                                        case 0x12: /* MSR CPSR */
                                        if (!(opcode&0xFF0))
                                        {
                                                temp=armregs[16];
                                                armregs[16]&=~msrlookup[(opcode>>16)&0xF];
                                                armregs[16]|=(armregs[RM]&msrlookup[(opcode>>16)&0xF]);
                                                templ=armregs[16];
//                                                if (output) rpclog("%07X CPSR now %08X\n",PC,armregs[16]);
                                                if (opcode&0x10000)
                                                {
                                                        updatemode(armregs[16]&0x1F);
                                                        if (!(mode&16)) {
                                                           armregs[15]=(armregs[15]&~3)|(armregs[16]&3);
                                                           armregs[15]=(armregs[15]&~0xC000000)|((armregs[16]&0xC0) << 20);
                                                        }
                                                }
                                                armregs[16]=templ;
                                        }
                                        else
                                        {
						bad_opcode(opcode);
                                        }
                                        break;
                                        
                                        case 0x13: /*TEQ reg*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                templ=armregs[15]&0x3FFFFFC;
                                                armregs[15]=((GETADDR(RN)^shift2(opcode))&0xFC000003)|templ;
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setzn(GETADDR(RN)^shift(opcode));
                                        }
                                        //cycles--;
                                        break;

                                        case 0x14: /* SWPB and MRS SPSR */
                                        if ((opcode&0xF0)==0x90) /* SWPB */
                                        {
                                                addr=armregs[RN];
                                                templ=GETREG(RM);
                                                LOADREG(RD,readmemb(addr));
                                                writememb(addr,templ);
                                                //cycles-=3;
                                        } else if (!(opcode&0xFFF)) /* MRS SPSR */
                                        {
                                                armregs[RD]=spsr[mode&15];
                                        }
                                        else
                                        {
						bad_opcode(opcode);
                                        }
                                        break;
                                        
                                        case 0x15: /*CMP reg*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                armregs[15]&=0x3FFFFFC;
                                                armregs[15]|=((GETADDR(RN)-shift2(opcode))&0xFC000003);
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                templ=shift2(opcode);
                                                setsub(GETADDR(RN),templ,GETADDR(RN)-templ);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x16:
                                        if (!(opcode&0xFF0)) /*MSR SPSR*/
                                        {
                                                temp=spsr[mode&15];
                                                spsr[mode&15]&=~msrlookup[(opcode>>16)&0xF];
                                                spsr[mode&15]|=(armregs[RM]&msrlookup[(opcode>>16)&0xF]);
                                        }
                                        else
                                        {
						bad_opcode(opcode);
                                        }
                                        break;

                                        case 0x17: /*CMN reg*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                armregs[15]&=0x3FFFFFC;
                                                armregs[15]|=((GETADDR(RN)+shift2(opcode))&0xFC000003);
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                           setadd(GETADDR(RN),shift2(opcode),GETADDR(RN)+shift2(opcode));
                                        //cycles--;
                                        break;

                                        case 0x18: /*ORR reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)|templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)|templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x19: /*ORRS reg*/
                                        if (RD==15)
                                        {
                                                templ=shift2(opcode);
                                                armregs[15]=(GETADDR(RN)|templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=shift(opcode);
                                                armregs[RD]=GETADDR(RN)|templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x1A: /*MOV reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(armregs[15]&~r15mask)|((templ+4)&r15mask);
                                                refillpipeline();
                                        }
                                        else
                                           armregs[RD]=templ;
                                        //cycles--;
                                        break;
                                        case 0x1B: /*MOVS reg*/
                                        if (RD==15)
                                        {
                                                armregs[15]=shift2(opcode)+4;
                                                if (mode&0x10)
                                                   armregs[16]=spsr[mode&15];
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                armregs[RD]=shift(opcode);
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x1C: /*BIC reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)&~templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)&~templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x1D: /*BICS reg*/
                                        if (RD==15)
                                        {
                                                templ=shift2(opcode);
                                                armregs[15]=(GETADDR(RN)&~templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=shift(opcode);
                                                armregs[RD]=GETADDR(RN)&~templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x1E: /*MVN reg*/
                                        templ=shift2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(armregs[15]&~r15mask)|(((~templ)+4)&r15mask);
                                                refillpipeline();
                                        }
                                        else
                                           armregs[RD]=~templ;
                                        //cycles--;
                                        break;
                                        case 0x1F: /*MVNS reg*/
                                        if (RD==15)
                                        {
                                                armregs[15]=(~shift2(opcode))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=~shift(opcode);
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x20: /*AND imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)&templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)&templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x21: /*ANDS imm*/
                                        if (RD==15)
                                        {
                                                templ=rotate2(opcode);
                                                armregs[15]=(GETADDR(RN)&templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=rotate(opcode);
                                                armregs[RD]=GETADDR(RN)&templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x22: /*EOR imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)^templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)^templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x23: /*EORS imm*/
                                        if (RD==15)
                                        {
                                                templ=rotate2(opcode);
                                                armregs[15]=(GETADDR(RN)^templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=rotate(opcode);
                                                armregs[RD]=GETADDR(RN)^templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x24: /*SUB imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)-templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)-templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x25: /*SUBS imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                if (mode&16) armregs[16]=spsr[mode&15];
                                                armregs[15]=(GETADDR(RN)-templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ2=GETADDR(RN);
                                                armregs[RD]=templ2-templ;
                                                setsub(templ2,templ,templ2-templ);
//                                                armregs[RD]=GETADDR(RN)-templ;
                                        }
                                        //cycles--;
                                        break;

                                        case 0x26: /*RSB imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((templ-GETADDR(RN))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=templ-GETADDR(RN);
                                        }
                                        //cycles--;
                                        break;
                                        case 0x27: /*RSBS imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(templ-GETADDR(RN))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsub(templ,GETADDR(RN),templ-GETADDR(RN));
                                                armregs[RD]=templ-GETADDR(RN);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x28: /*ADD imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)+templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)+templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x29: /*ADDS imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=GETADDR(RN)+templ+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                setadd(GETADDR(RN),templ,GETADDR(RN)+templ);
                                                armregs[RD]=GETADDR(RN)+templ;
                                        }
                                        //cycles--;
                                        break;

                                        case 0x2A: /*ADC imm*/
                                        templ2=CFSET;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=((GETADDR(RN)+templ+templ2+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)+templ+templ2;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x2B: /*ADCS imm*/
                                        templ2=CFSET;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=GETADDR(RN)+templ+templ2+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setadc(GETADDR(RN),templ,GETADDR(RN)+templ+templ2);
                                                armregs[RD]=GETADDR(RN)+templ+templ2;
                                        }
                                        //cycles--;
                                        break;

                                        case 0x2C: /*SBC imm*/
                                        templ2=(CFSET)?0:1;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)-(templ+templ2))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)-(templ+templ2);
                                        }
                                        //cycles--;
                                        break;
                                        case 0x2D: /*SBCS imm*/
                                        templ2=(CFSET)?0:1;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(GETADDR(RN)-(templ+templ2))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsbc(GETADDR(RN),templ,GETADDR(RN)-(templ+templ2));
                                                armregs[RD]=GETADDR(RN)-(templ+templ2);
                                        }
                                        //cycles--;
                                        break;
                                        case 0x2E: /*RSC imm*/
                                        templ2=(CFSET)?0:1;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((templ-(GETADDR(RN)+templ2))+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=templ-(GETADDR(RN)+templ2);
                                        }
                                        //cycles--;
                                        break;
                                        case 0x2F: /*RSCS imm*/
                                        templ2=(CFSET)?0:1;
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(templ-(GETADDR(RN)+templ2))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setsbc(templ,GETADDR(RN),templ-(GETADDR(RN)+templ2));
                                                armregs[RD]=templ-(GETADDR(RN)+templ2);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x31: /*TST imm*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                templ=armregs[15]&0x3FFFFFC;
                                                armregs[15]=((GETADDR(RN)&rotate2(opcode))&0xFC000003)|templ;
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setzn(GETADDR(RN)&rotate(opcode));
                                        }
                                        //cycles--;
                                        break;
                                
                                        case 0x32: /*MSR rot->flags*/
/*                                        if ((opcode&0x3FF000)==0x28F000)
                                        {
                                                templ=rotate(opcode);
                                                armregs[cpsr]=(armregs[cpsr]&~0xF0000000)|(templ&0xF0000000);
                                        }*/

					templ = rotate2(opcode);

//					if (output)
//						rpclog("MSR: %08x (%08x - %08x)\n", opcode, armregs[15], armregs[16]);

					if (mode & 0xF) {
						if (opcode & 0x10000) {
							armregs[16] = (armregs[16] & ~ 0xFF) | (templ & 0xFF);
							if ((mode & 0x10) == 0) {
								armregs[15] = (armregs[15] & ~ 0x3) | (templ & 0x3);
								armregs[15] = (armregs[15] & ~ 0xC000000) | ((templ & 0xC0) << 20);
							}
						}
						if (opcode & 0x20000)
							armregs[16] = (armregs[16] & ~ 0xFF00) | (templ & 0xFF00);
						if (opcode & 0x40000)
							armregs[16] = (armregs[16] & ~ 0xFF0000) | (templ & 0xFF0000);
					}

                                        if (opcode & 0x80000) {
						armregs[16] = (armregs[16] & ~ 0xFF000000) | (templ & 0xFF000000);
						if ((mode & 0x10) == 0) {
							armregs[15] = (armregs[15] & ~ 0xF0000000) | (templ & 0xF0000000);
						}
					}

//					if (output)
//						rpclog("%08x - %08x\n", armregs[15], armregs[16]);

					if ((armregs[16] & 0x1F) != mode) {
//						if (output)
//							rpclog("changing mode to %02x (was %02x)\n", armregs[16] & 0x1F, mode);

						updatemode(armregs[16] & 0x1F);
					}


                                        //cycles--;
                                        break;

                                        case 0x33: /*TEQ imm*/
                                        if (RD==15)
                                        {
/*                                                if (mode&16)
                                                {
                                                        error("TEQP in 32-bit mode %08X\n",rotate2(opcode));
                                                        dumpregs();
                                                        exit(-1);
                                                }*/
                                                opcode&=~0x100000;
                                                if (armregs[15]&3)
                                                {
                                                        templ=armregs[15]&0x3FFFFFC;
                                                        armregs[15]=((GETADDR(RN)^rotate2(opcode))&0xFC000003)|templ;
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                                }
                                                else
                                                {
                                                        templ=armregs[15]&0x0FFFFFFF;
                                                        armregs[15]=((GETADDR(RN)^rotate2(opcode))&0xF0000000)|templ;
                                                }
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                setzn(GETADDR(RN)^rotate(opcode));
                                        }
                                        //cycles--;
                                        break;

                                        case 0x35: /*CMP imm*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                armregs[15]&=0x3FFFFFC;
                                                armregs[15]|=((GETADDR(RN)-rotate2(opcode))&0xFC000003);
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                        {
                                                templ=rotate2(opcode);
                                                templ2=GETADDR(RN);
                                                setsub(templ2,templ,templ2-templ);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x37: /*CMN imm*/
                                        if (RD==15)
                                        {
                                                opcode&=~0x100000;
                                                armregs[15]&=0x3FFFFFC;
                                                armregs[15]|=((GETADDR(RN)+rotate2(opcode))&0xFC000003);
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
//                                                refillpipeline();
                                        }
                                        else
                                           setadd(GETADDR(RN),rotate2(opcode),GETADDR(RN)+rotate2(opcode));
                                        //cycles--;
                                        break;

                                        case 0x38: /*ORR imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)|templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)|templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x39: /*ORRS imm*/
                                        if (RD==15)
                                        {
                                                templ=rotate2(opcode);
                                                if (armregs[15]&3)
                                                   armregs[15]=(GETADDR(RN)|templ)+4;
                                                else
                                                   armregs[15]=(((GETADDR(RN)|templ)+4)&0xF3FFFFFC)|(armregs[15]&0xC000003);
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=rotate(opcode);
                                                armregs[RD]=GETADDR(RN)|templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x3A: /*MOV imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(armregs[15]&~r15mask)|(templ&r15mask);
                                                refillpipeline();
                                        }
                                        else
                                           armregs[RD]=templ;
                                        //cycles--;
                                        break;
                                        case 0x3B: /*MOVS imm*/
                                        if (RD==15)
                                        {
                                                armregs[15]=rotate2(opcode)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                armregs[RD]=rotate(opcode);
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x3C: /*BIC imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(((GETADDR(RN)&~templ)+4)&r15mask)|(armregs[15]&~r15mask);
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=GETADDR(RN)&~templ;
                                        }
                                        //cycles--;
                                        break;
                                        case 0x3D: /*BICS imm*/
                                        if (RD==15)
                                        {
                                                templ=rotate2(opcode);
                                                armregs[15]=(GETADDR(RN)&~templ)+4;
                                                refillpipeline();
                                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        else
                                        {
                                                templ=rotate(opcode);
                                                armregs[RD]=GETADDR(RN)&~templ;
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;

                                        case 0x3E: /*MVN imm*/
                                        templ=rotate2(opcode);
                                        if (RD==15)
                                        {
                                                armregs[15]=(armregs[15]&~r15mask)|(((~templ)+4)&r15mask);
                                                refillpipeline();
                                        }
                                        else
                                           armregs[RD]=~templ;
                                        //cycles--;
                                        break;
                                        case 0x3F: /*MVNS imm*/
                                        if (RD==15)
                                        {
                                                armregs[15]=(~rotate2(opcode))+4;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                armregs[RD]=~rotate(opcode);
                                                setzn(armregs[RD]);
                                        }
                                        //cycles--;
                                        break;
//#endif
#ifdef NEWLDRSTR
			case 0x40:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x41:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x42:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x43:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x44:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x45:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x46:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x47:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x48:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x49:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x4A:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x4B:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x4C:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x4D:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x4E:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x4F:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x50:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x51:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x52:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x53:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x54:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x55:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			templ=readmemb(addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x56:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x57:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr-=addr2;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x58:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x59:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x5A:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x5B:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x5C:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x5D:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			templ=readmemb(addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x5E:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x5F:
			addr=GETADDR(RN);
			addr2=opcode&0xFFF;
			addr+=addr2;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x60:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x61:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x62:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x63:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x64:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x65:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x66:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr-addr2;
			//cycles-=2;
			break;

			case 0x67:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr-addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x68:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x69:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x6A:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x6B:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x6C:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x6D:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x6E:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr+addr2;
			//cycles-=2;
			break;

			case 0x6F:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr+addr2;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x70:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x71:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x72:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x73:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x74:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x75:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			templ=readmemb(addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x76:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x77:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr-=addr2;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x78:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x79:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x7A:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			writememl(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x7B:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			templ=readmeml(addr);
		templ=ldrresult(templ,addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x7C:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			//cycles-=2;
			break;

			case 0x7D:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			templ=readmemb(addr);
		if (databort) break;
			LOADREG(RD,templ);
			//cycles-=2;
			break;

			case 0x7E:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			writememb(addr,armregs[RD]);
		if (databort) break;
			armregs[RN]=addr;
			//cycles-=2;
			break;

			case 0x7F:
			addr=GETADDR(RN);
			addr2=shift2(opcode);
			addr+=addr2;
			templ=readmemb(addr);
		if (databort) break;
			armregs[RN]=addr;
			LOADREG(RD,templ);
			//cycles-=2;
			break;



#else
                                        case 0x42: case 0x4A: /*STRT*/
                                        case 0x62: case 0x6A:
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        templ=memmode;
                                        memmode=0;
                                        writememl(addr,armregs[RD]);
                                        memmode=templ;
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        //cycles-=2;
                                        break;

                                        case 0x43: case 0x4B: /*LDRT*/
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        templ=memmode;
                                        memmode=0;
                                        templ2=readmeml(addr&~3);
                                        memmode=templ;
                                        if (armirq&0x40) break;
                                        if (addr&3) templ2=ldrresult(templ2,addr);
//                                        if (RD==15) refillpipeline();
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        LOADREG(RD,templ2);
                                        //cycles-=3;
                                        break;

                                        case 0x66: case 0x6E: /*STRBT*/
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        templ=memmode;
                                        memmode=0;
                                        writememb(addr,armregs[RD]);
                                        memmode=templ;
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        //cycles-=2;
                                        break;

                                        case 0x47: case 0x4F: /*LDRBT*/
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        templ=memmode;
                                        memmode=0;
                                        templ2=readmemb(addr);
                                        memmode=templ;
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        LOADREG(RD,templ2);
                                        //cycles-=3;
                                        break;
//#if 0
                                        case 0x46: /*STRB RD,[RN],-#*/
                                        writememb(armregs[RN],armregs[RD]);
                                        if (armirq&0x40) break;
                                        armregs[RN]-=(opcode&0xFFF);
                                        break;

			             case 0x4C: /*STRB RD,[RN],#*/
                                     writememb(armregs[RN],armregs[RD]);
		                     if (armirq&0x40) break;
        			     armregs[RN]+=(opcode&0xFFF);
			             //cycles-=2;
//			             rpclog("STRB %07X\n",PC);
			             break;

                			case 0x59: /*LDR RD,[RN,#]*/
                                        addr=GETADDR(RN)+(opcode&0xFFF);
                                        templ=readmeml(addr&~3);
                        		if (addr&3) templ=ldrresult(templ,addr);
                               		if (armirq&0x40) break;
                			LOADREG(RD,templ);
                			break;

                			case 0x79: /*LDR RD,[RN,shift]*/
                			addr=GETADDR(RN)+shift_ldrstr(opcode);
                                        templ=readmeml(addr&~3);
                        		if (addr&3) templ=ldrresult(templ,addr);
                        		if (armirq&0x40) break;
                			LOADREG(RD,templ);
                			break;

                			case 0x7D: /*LDRB RD,[RN,shift]*/
                			addr=GETADDR(RN)+shift_ldrstr(opcode);
                                        templ=readmemb(addr);
                                        if (armirq&0x40) break;
                        		armregs[RD]=templ;
                			break;
//#endif

                                        case 0x60: case 0x68:
                                        case 0x70: case 0x72: case 0x78: case 0x7A:
                                        case 0x40: case 0x48: /*STR*/
                                        case 0x50: case 0x52: case 0x58: case 0x5A:
                                        if ((opcode&0x2000010)==0x2000010)
                                        {
                                                undefined();
                                                break;
                                        }
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        if (RD==15) { writememl(addr&~3,armregs[RD]+r15diff); }
                                        else        { writememl(addr&~3,armregs[RD]); }
                                        if (armirq&0x40)
                                        {
//                                                rpclog("Data abort\n");
                                                break;
                                        }
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        //cycles-=2;
                                        break;

                                        case 0x41: case 0x49: /*LDR*/
                                        case 0x51: case 0x53: /*case 0x59: */case 0x5B:
                                        case 0x61: case 0x69:
                                        case 0x71: case 0x73: /*case 0x79:*/ case 0x7B:
                                        if ((opcode&0x2000010)==0x2000010)
                                        {
                                                undefined();
                                                break;
                                        }
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        templ=readmeml(addr&~3);
                                        if (addr&3) templ=ldrresult(templ,addr);
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        LOADREG(RD,templ);
                                        break;

                                        case 0x65: case 0x6D:
                                        case 0x75: case 0x77: /*case 0x7D:*/ case 0x7F:
                                        if (opcode&0x10)
                                        {
                                                undefined();
                                                break;
                                        }
                                        case 0x45: case 0x4D: /*LDRB*/
                                        case 0x55: case 0x57: case 0x5D: case 0x5F:
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)    addr+=addr2;
                                        templ=readmemb(addr);
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        armregs[RD]=templ;
                                        //cycles-=3;
                                        break;

                                        case 0x64: case 0x6C:
                                        case 0x74: case 0x76: case 0x7C: case 0x7E:
                                        if (opcode&0x10)
                                        {
                                                undefined();
                                                break;
                                        }
                                        case 0x44: /*case 0x4C:*/ case 0x4E: /*STRB*/
                                        case 0x54: case 0x56: case 0x5C: case 0x5E:
                                        addr=GETADDR(RN);
                                        if (opcode&0x2000000) addr2=shift_ldrstr(opcode);
                                        else                  addr2=opcode&0xFFF;
                                        if (!(opcode&0x800000))  addr2=-addr2;
                                        if (opcode&0x1000000)
                                        {
                                                addr+=addr2;
                                        }
                                        writememb(addr,armregs[RD]);
                                        if (armirq&0x40) break;
                                        if (!(opcode&0x1000000))
                                        {
                                                addr+=addr2;
                                                armregs[RN]=addr;
                                        }
                                        else
                                        {
                                                if (opcode&0x200000) armregs[RN]=addr;
                                        }
                                        //cycles-=2;
                                        break;
#endif
                                        
/*                                        case 0x80: case 0x81: case 0x82: case 0x83:
                                        case 0x84: case 0x85: case 0x86: case 0x87:
                                        case 0x88: case 0x89: case 0x8A: case 0x8B:
                                        case 0x8C: case 0x8D: case 0x8E: case 0x8F:
                                        case 0x90: case 0x91: case 0x92: case 0x93:
                                        case 0x94: case 0x95: case 0x96: case 0x97:
                                        case 0x98: case 0x99: case 0x9A: case 0x9B:
                                        case 0x9C: case 0x9D: case 0x9E: case 0x9F:
                                        ldmstm((opcode>>20)&0xFF, opcode);
                                        //cycles--;
                                        break;*/

#define STMfirst()      mask=1; \
                        for (c=0;c<15;c++) \
                        { \
                                if (opcode&mask) \
                                { \
                                        if (!(addr&0xC)) cycles--; \
                                        if (c==15) { writememl(addr,armregs[c]+4); } \
                                        else       { writememl(addr,armregs[c]); } \
                                        addr+=4; \
                                        cycles--; \
                                        break; \
                                } \
                                mask<<=1; \
                        } \
                        mask<<=1; c++;

#define STMall()        for (;c<15;c++) \
                        { \
                                if (opcode&mask) \
                                { \
                                        if (!(addr&0xC)) cycles--; \
                                        writememl(addr,armregs[c]); \
                                        addr+=4; \
                                        cycles--; \
                                } \
                                mask<<=1; \
                        } \
                        if (opcode&0x8000) \
                        { \
                                if (!(addr&0xC)) cycles--; \
                                writememl(addr,armregs[15]+4); \
                                cycles--; \
                        }

#define STMfirstS()     mask=1; \
                        for (c=0;c<15;c++) \
                        { \
                                if (opcode&mask) \
                                { \
                                        if (!(addr&0xC)) cycles--; \
                                        if (c==15) { writememl(addr,armregs[c]+4); } \
                                        else       { writememl(addr,*usrregs[c]); } \
                                        addr+=4; \
                                        cycles--; \
                                        break; \
                                } \
                                mask<<=1; \
                        } \
                        mask<<=1; c++;

#define STMallS()       for (;c<15;c++) \
                        { \
                                if (opcode&mask) \
                                { \
                                        if (!(addr&0xC)) cycles--; \
                                        writememl(addr,*usrregs[c]); \
                                        addr+=4; \
                                        cycles--; \
                                } \
                                mask<<=1; \
                        } \
                        if (opcode&0x8000) \
                        { \
                                if (!(addr&0xC)) cycles--; \
                                writememl(addr,armregs[15]+4); \
                                cycles--; \
                        }

#define LDMall()        mask=1; \
                        for (c=0;c<15;c++) \
                        { \
                                if (opcode&mask) \
                                { \
                                        if (!(addr&0xC)) cycles--; \
                                        armregs[c]=readmeml(addr); \
                                        addr+=4; \
                                        cycles--; \
                                } \
                                mask<<=1; \
                        } \
                        if (opcode&0x8000) \
                        { \
                                if (!(addr&0xC)) cycles--; \
                                armregs[15]=(armregs[15]&~r15mask)|((readmeml(addr)+4)&r15mask); \
                                cycles--; \
                                refillpipeline(); \
                        }

#define LDMallS()       mask=1; \
                        if (opcode&0x8000) \
                        { \
                                for (c=0;c<15;c++) \
                                { \
                                        if (opcode&mask) \
                                        { \
                                                if (!(addr&0xC)) cycles--; \
                                                armregs[c]=readmeml(addr); \
                                                addr+=4; \
                                                cycles--; \
                                        } \
                                        mask<<=1; \
                                } \
                                if (!(addr&0xC)) cycles--; \
                                if ((armregs[15]&3) || (mode&16)) armregs[15]=(readmeml(addr)+4); \
                                else                              armregs[15]=(armregs[15]&0x0C000003)|((readmeml(addr)+4)&0xF3FFFFFC); \
                                if (mode&16) armregs[cpsr]=spsr[mode&15]; \
                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask); \
                                cycles--; \
                                refillpipeline(); \
                        } \
                        else \
                        { \
                                for (c=0;c<15;c++) \
                                { \
                                        if (opcode&mask) \
                                        { \
                                                if (!(addr&0xC)) cycles--; \
                                                *usrregs[c]=readmeml(addr); \
                                                addr+=4; \
                                                cycles--; \
                                        } \
                                        mask<<=1; \
                                } \
                        }

                                        case 0x80: /*STMDA*/
                                        case 0x82: /*STMDA !*/
                                        case 0x90: /*STMDB*/
                                        case 0x92: /*STMDB !*/
                                        templ=armregs[RN];
                                        addr=(armregs[RN]&~3)-countbits(opcode&0xFFFF);
                                        if (!(opcode&0x1000000)) addr+=4;
                                        STMfirst();
                                        if (opcode&0x200000) armregs[RN]-=countbits(opcode&0xFFFF);
                                        STMall()
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles--;
                                        break;
                                        case 0x88: /*STMIA*/
                                        case 0x8A: /*STMIA !*/
                                        case 0x98: /*STMIB*/
                                        case 0x9A: /*STMIB !*/
                                        templ=armregs[RN];
                                        addr=armregs[RN]&~3;
                                        if (opcode&0x1000000) addr+=4;
                                        STMfirst();
                                        if (opcode&0x200000) armregs[RN]+=countbits(opcode&0xFFFF);
                                        STMall();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles--;
                                        break;
                                        case 0x84: /*STMDA ^*/
                                        case 0x86: /*STMDA ^!*/
                                        case 0x94: /*STMDB ^*/
                                        case 0x96: /*STMDB ^!*/
                                        templ=armregs[RN];
                                        addr=(armregs[RN]&~3)-countbits(opcode&0xFFFF);
                                        if (!(opcode&0x1000000)) addr+=4;
                                        STMfirstS();
                                        if (opcode&0x200000) armregs[RN]-=countbits(opcode&0xFFFF);
                                        STMallS()
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles--;
                                        break;
                                        case 0x8C: /*STMIA ^*/
                                        case 0x8E: /*STMIA ^!*/
                                        case 0x9C: /*STMIB ^*/
                                        case 0x9E: /*STMIB ^!*/
                                        templ=armregs[RN];
                                        addr=armregs[RN]&~3;
                                        if (opcode&0x1000000) addr+=4;
                                        STMfirstS();
                                        if (opcode&0x200000) armregs[RN]+=countbits(opcode&0xFFFF);
                                        STMallS();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles--;
                                        break;

                                        case 0x81: /*LDMDA*/
                                        case 0x83: /*LDMDA !*/
                                        case 0x91: /*LDMDB*/
                                        case 0x93: /*LDMDB !*/
                                        templ=armregs[RN];
                                        addr=(armregs[RN]&~3)-countbits(opcode&0xFFFF);
                                        if (!(opcode&0x1000000)) addr+=4;
                                        if (opcode&0x200000) armregs[RN]-=countbits(opcode&0xFFFF);
                                        LDMall();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles-=2;
                                        break;
                                        case 0x89: /*LDMIA*/
                                        case 0x8B: /*LDMIA !*/
                                        case 0x99: /*LDMIB*/
                                        case 0x9B: /*LDMIB !*/
                                        templ=armregs[RN];
                                        addr=armregs[RN]&~3;
                                        if (opcode&0x1000000) addr+=4;
                                        if (opcode&0x200000) armregs[RN]+=countbits(opcode&0xFFFF);
                                        LDMall();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles-=2;
                                        break;
                                        case 0x85: /*LDMDA ^*/
                                        case 0x87: /*LDMDA ^!*/
                                        case 0x95: /*LDMDB ^*/
                                        case 0x97: /*LDMDB ^!*/
                                        templ=armregs[RN];
                                        addr=(armregs[RN]&~3)-countbits(opcode&0xFFFF);
                                        if (!(opcode&0x1000000)) addr+=4;
                                        if (opcode&0x200000) armregs[RN]-=countbits(opcode&0xFFFF);
                                        LDMallS();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles-=2;
                                        break;
                                        case 0x8D: /*LDMIA ^*/
                                        case 0x8F: /*LDMIA ^!*/
                                        case 0x9D: /*LDMIB ^*/
                                        case 0x9F: /*LDMIB ^!*/
                                        templ=armregs[RN];
                                        addr=armregs[RN]&~3;
                                        if (opcode&0x1000000) addr+=4;
                                        if (opcode&0x200000) armregs[RN]+=countbits(opcode&0xFFFF);
                                        LDMallS();
                                        if (armirq&0x40) armregs[RN]=templ;
                                        cycles-=2;
                                        break;

                                        case 0xB0: case 0xB1: case 0xB2: case 0xB3: /*BL*/
                                        case 0xB4: case 0xB5: case 0xB6: case 0xB7:
                                        case 0xB8: case 0xB9: case 0xBA: case 0xBB:
                                        case 0xBC: case 0xBD: case 0xBE: case 0xBF:
                                        templ=(opcode&0xFFFFFF)<<2;
                                        if (templ&0x2000000) templ|=0xFC000000;
                                        armregs[14]=armregs[15]-4;
                                        armregs[15]=((armregs[15]+templ+4)&r15mask)|(armregs[15]&~r15mask);
                                        refillpipeline();
                                        //cycles-=3;
                                        break;

                                        case 0xA0: case 0xA1: case 0xA2: case 0xA3: /*B*/
                                        case 0xA4: case 0xA5: case 0xA6: case 0xA7:
                                        case 0xA8: case 0xA9: case 0xAA: case 0xAB:
                                        case 0xAC: case 0xAD: case 0xAE: //case 0xAF:
                                        templ=(opcode&0xFFFFFF)<<2;
                                        if (templ&0x2000000) templ|=0xFC000000;
                                        armregs[15]=((armregs[15]+templ+4)&r15mask)|(armregs[15]&~r15mask);
#ifdef PREFETCH
        templ=(PC-4)>>2;
        if ((templ>>10)!=pccache)
        {
                pccache=templ>>10;
                pccache2=getpccache(templ<<2);
                if (pccache2==NULL) pccache=0xFFFFFFFF;
                else                opcode2=pccache2[templ];
        }
        else opcode2=pccache2[templ];
        templ++;
        if (!(templ&0x3FF) || pccache2==NULL)
        {
                pccache=templ>>10;
                pccache2=getpccache(templ<<2);
                if (pccache2==NULL) pccache=0xFFFFFFFF;
                else                opcode3=pccache2[templ];
        }
        else opcode3=pccache2[templ];
#endif
//                                        refillpipeline();
                                        //cycles-=3;
                                        break;
#if 1
                                        case 0xAF: /*B*/
                                        templ=((opcode&0xFFFFFF)<<2)|0xFC000000;
//                                        if (templ&0x2000000) templ|=0xFC000000;
                                        armregs[15]=((armregs[15]+templ+4)&r15mask)|(armregs[15]&~r15mask);
#ifdef PREFETCH
        templ=(PC-4)>>2;
        if ((templ>>10)==pccache)
        {
                opcode2=pccache2[templ];
                opcode3=pccache2[templ+1];
        }
        else
        {
                pccache=templ>>10;
                pccache2=getpccache(templ<<2);
                if (pccache2==0xFFFFFFFF) pccache=0xFFFFFFFF;
                else                      opcode2=pccache2[templ];
                templ++;
                if (!(templ&0x3FF) || pccache2==NULL)
                {
                        pccache=templ>>10;
                        pccache2=getpccache(templ<<2);
                        if (pccache2==NULL) pccache=0xFFFFFFFF;
                        else                opcode3=pccache2[templ];
                }
                else opcode3=pccache2[templ];
        }
#endif
//                                        refillpipeline();
                                        //cycles-=3;
                                        break;
#endif
                                        case 0xE0: case 0xE2: case 0xE4: case 0xE6: /*MCR*/
                                        case 0xE8: case 0xEA: case 0xEC: case 0xEE:
#ifdef FPA
                                        if (MULRS==1)
                                        {
                                                fpaopcode(opcode);
                                        }
                                        else
#endif
                                        if (MULRS==15 && (opcode&0x10))
                                        {
                                                writecp15(RN,armregs[RD],opcode);
                                        }
                                        else
                                        {
                                                undefined();
                                        }
                                        break;

                                        case 0xE1: case 0xE3: case 0xE5: case 0xE7: /*MRC*/
                                        case 0xE9: case 0xEB: case 0xED: case 0xEF:
#ifdef FPA
                                        if (MULRS==1)
                                        {
                                                fpaopcode(opcode);
                                        }
                                        else
#endif
                                        if (MULRS==15 && (opcode&0x10))
                                        {
                                                if (RD==15) armregs[RD]=(armregs[RD]&r15mask)|(readcp15(RN)&~r15mask);
                                                else        armregs[RD]=readcp15(RN);
                                        }
                                        else
                                        {
                                                undefined();
                                        }
                                        break;

//#if 0
                                        case 0xC0: case 0xC1: case 0xC2: case 0xC3: /*Co-pro*/
                                        case 0xC4: case 0xC5: case 0xC6: case 0xC7:
                                        case 0xC8: case 0xC9: case 0xCA: case 0xCB:
                                        case 0xCC: case 0xCD: case 0xCE: case 0xCF:
                                        case 0xD0: case 0xD1: case 0xD2: case 0xD3:
                                        case 0xD4: case 0xD5: case 0xD6: case 0xD7:
                                        case 0xD8: case 0xD9: case 0xDA: case 0xDB:
                                        case 0xDC: case 0xDD: case 0xDE: case 0xDF:
#ifdef FPA
                                        if ((opcode&0xF00)==0x100 || (opcode&0xF00)==0x200)
                                           fpaopcode(opcode);
                                        else
                                        {
                                                undefined();
                                        }
#else
                                        undefined();
#endif
                                        break;
//#endif
                                        case 0xF0: case 0xF1: case 0xF2: case 0xF3: /*SWI*/
                                        case 0xF4: case 0xF5: case 0xF6: case 0xF7:
                                        case 0xF8: case 0xF9: case 0xFA: case 0xFB:
                                        case 0xFC: case 0xFD: case 0xFE: case 0xFF:
                                        templ=opcode&0xDFFFF;
//                                        if (templ==0x34) printf("OS_CallAVector %08X %08X %08X\n",armregs[9],armregs[0],armregs[1]);
                                        if (mousehack && templ==7 && armregs[0]==0x15)
                                        {
//                                                printf("OSWORD call %i\n",readmemb(armregs[1]));
                                                if (readmemb(armregs[1])==1)
                                                {
                                                        setmouseparams(armregs[1]);
                                                        break;
                                                }
                                                else if (readmemb(armregs[1])==4)
                                                {
                                                        getunbufmouse(armregs[1]);
                                                        break;
                                                }
                                                else if (readmemb(armregs[1])==3)
                                                {
                                                        setmousepos(armregs[1]);
                                                        break;
                                                }
                                                else if (readmemb(armregs[1])==5)
                                                {
                                                        setmousepos(armregs[1]);
                                                        break;
                                                }
                                                else
                                                  goto realswi;
                                        }
                                        else if (mousehack && templ==0x1C)
                                        {
                                                getosmouse();
                                                armregs[15]&=~VFLAG;
                                        }
                                        else if (templ == ARCEM_SWI_HOSTFS)
					  {
//                                                        rpclog("HOSTFS SWI\n");
//                                                        dbug_hostfs("ARCEM_SWI %08X\n",templ);
					    ARMul_State state;
					    state.Reg = armregs;
					    hostfs(&state);
//					    dbug_hostfs("Results : %08X %08X %08X %08X\n",armregs[2],armregs[3],armregs[4],armregs[5]);
					  }
                                        else if (templ == ARCEM_SWI_NANOSLEEP)
                                          {
#ifdef RPCEMU_WIN
                                            Sleep(armregs[0]/1000000);
#else
                                            struct timespec tm;
                                            tm.tv_sec = 0;
                                            tm.tv_nsec = armregs[0];
                                            nanosleep(&tm, NULL);
#endif
                                            armregs[15]&=~VFLAG;
                                          }
#ifdef RPCEMU_LINUX
                                        else if (templ == ARCEM_SWI_NETWORK)
                                          {
                                              networkswi(armregs[0], armregs[1], armregs[2], armregs[3], armregs[4], armregs[5], &armregs[0], &armregs[1]);
                                          }
#endif
					else
					  {
                                                        realswi:
                                                        if (mousehack && templ==7 && armregs[0]==0x15 && readmemb(armregs[1])==0)
                                                           setpointer(armregs[1]);
                                                        if (mousehack && templ==6 && armregs[0]==106)
                                                           osbyte106(armregs[1]);
//                                                        templ=armregs[15]-4;
exception(SUPERVISOR,0xC,4);

/*
                                                if (mode&16)
                                                {
                                                        templ=armregs[15]-4;
                                                        spsr[SUPERVISOR]=armregs[16];
                                                        updatemode(SUPERVISOR|16);
                                                        armregs[14]=templ;
                                                        armregs[16]&=~0x1F;
                                                        armregs[16]|=0x93;
                                                        armregs[15]=0x0000000C;
                                                        refillpipeline();
                                                }
                                                else if (prog32)
                                                {
                                                        templ=armregs[15]-4;
                                                        updatemode(SUPERVISOR|16);
                                                        armregs[14]=templ&0x3FFFFFC;
                                                        spsr[SUPERVISOR]=(armregs[16]&~0x1F)|(templ&3);
                                                        armregs[15]=0x0000000C;
                                                        armregs[16]|=0x80;
                                                        //cycles-=4;
                                                        refillpipeline();
                                                }
                                                else
                                                {
                                                        templ=armregs[15]-4;
                                                        armregs[15]|=3;
                                                        updatemode(SUPERVISOR);
                                                        armregs[14]=templ;
                                                        armregs[15]&=0xFC000003;
                                                        armregs[15]|=0x0800000C;
                                                        //cycles-=4;
                                                        refillpipeline();
                                                }*/
//        templ=(PC-4)>>2;
//refillpipeline();
//                                        if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                                        }
                                        break;

				          default:
					    {
/*					      int ls_opcode = (opcode >> 20) & 0xff;

					      if (ls_opcode >= 0x80 && ls_opcode <= 0xa0)
					        ldmstm(ls_opcode, opcode);
                                              else*/
					        bad_opcode(opcode);
					    }
                                }
                        }
#ifdef STRONGARM
                        }
#endif
                        if (/*databort|*/armirq)//|prefabort)
                        {
/*                                if (mode&16)
                                {
                                        printf("32-bit Exception %i %i %i\n",databort,armirq,prefabort);
                                        dumpregs();
                                        exit(-1);
                                }
                                else*/
                                if (!(mode&16))
                                {
                                        armregs[16]&=~0xC0;
                                        armregs[16]|=((armregs[15]&0xC000000)>>20);
                                }
//                                if (output) rpclog("Exception process - %i %i %i %08X %08X %i\n",databort,armirq,prefabort,armregs[15],armregs[16],inscount);
//                                if (out2) printf("PC at the moment %07X %i %i %02X %08X\n",PC,ins,mode,armregs[16]&0xC0,armregs[15]);
                                if (armirq&0xC0)
                                {
//                                        exception(ABORT,(armirq&0x80)?0x10:0x14,0);
//                                        armirq&=~0xC0;
//                                        #if 0
                                if (armirq&0x80)//prefabort)       /*Prefetch abort*/
                                {
                                        armirq&=~0xC0;
                                        exception(ABORT,0x10,0);
                                }
                                else if (armirq&0x40)//databort==1)     /*Data abort*/
                                {
                                        armirq&=~0xC0;
                                        exception(ABORT,0x14,-4);
                                }
                                else if (databort==2) /*Address Exception*/
                                {
                                error("Exception %i %i %i\n",databort,armirq,prefabort);
                                dumpregs();
                                exit(-1);
                                        templ=armregs[15];
                                        armregs[15]|=3;
                                        updatemode(SUPERVISOR);
                                        armregs[14]=templ;
                                        armregs[15]&=0xFC000003;
                                        armregs[15]|=0x08000018;
                                        refillpipeline();
                                        databort=0;
                                }
//                                #endif
                                }
                                else if ((armirq&2) && !(armregs[16]&0x40)) /*FIQ*/
                                {
//                                        printf("FIQ %02X %02X\n",iomd.statf,iomd.maskf);
                                        exception(FIQ,0x20,0);
                                }
                                else if ((armirq&1) && !(armregs[16]&0x80)) /*IRQ*/
                                {
//                                        if (output) rpclog("IRQ %02X %02X %02X %02X %08X %08X %02X %08X\n",iomd.stata&iomd.maska,iomd.statb&iomd.maskb,iomd.statc&iomd.maskc,iomd.statd&iomd.maskd,PC,armregs[13],mode,irqregs[0]);
//                                        if (output) printf("IRQ %i %i\n",prog32,mode&16);
//                                        exception(IRQ,0x1C,0x80,0);
                                        if (mode&16)
                                        {
                                                templ=armregs[15];
                                                spsr[IRQ]=armregs[16];
                                                updatemode(IRQ|16);
                                                armregs[14]=templ;
                                                armregs[16]&=~0x1F;
                                                armregs[16]|=0x92;
                                                armregs[15]=0x00000001C;
                                                refillpipeline();
//                                                timetolive=500;
                                        }
                                        else if (prog32)
                                        {
                                                templ=armregs[15];
                                                updatemode(IRQ|16);
                                                armregs[14]=templ&0x3FFFFFC;
                                                spsr[IRQ]=(armregs[16]&~0x1F)|(templ&3);
                                                armregs[16]|=0x80;
                                                armregs[15]=0x00000001C;
                                                refillpipeline();
                                        }
                                        else
                                        {
                                                templ=armregs[15];
                                                armregs[15]|=3;
                                                updatemode(IRQ);
                                                armregs[14]=templ;
                                                armregs[15]&=0xFC000002;
                                                armregs[15]|=0x0800001C;
                                                refillpipeline();
                                        }
                                }
//                                if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                        }
//                        armirq=irq;
                        armregs[15]+=4;
/*                        if (armregs[13]==0x1F00000 && armregs[13]!=oldr13)
                        {
                                rpclog("R13 = 1EFFFF0 from %08X\n",oldr13);
                        }
                        oldr13=armregs[13];*/
/*                        if (PC==0x8008)
                        {
                                rpclog("Hit 8000\n");
                                times8000++;
                                output=1;
                                ins=0;
                        }*/
//                        if (PC==0x14820) armregs[6]=0x8;
                #if 0
                        if (PC==(lastswi+4))
                        {
                                lastswi=0xFFFFFFFF;
                                rpclog("Last SWI exited with V %s  %08X %08X %08X %08X\n",(armregs[15]&VFLAG)?"set":"clear",armregs[0],armregs[1],armregs[2],armregs[3]);
                        }
                        inssinceswi++;
                        if (inssinceswi==207229) output=0;
                        #endif
//                        ins++;
//                        if ((armregs[cpsr]&mmask)!=mode) updatemode(armregs[cpsr]&mmask);
                        #if 0
                        if (output)
                        {
                                ins++;
                                if (swiout && ins>59) output=2;
//                                if (times8000==9 && ins==6600000) output=2;
//                                if (ins==88990000) output=2;
                        }*/
                        if (output)
                        {
                                       rpclog(":%08X %08X %08X %08X %08X %08X %08X %08X %08X  %08X %08X %08X %08X\n",PC,armregs[0],armregs[1],armregs[2],armregs[3],armregs[4],armregs[5],armregs[6],armregs[7],oldpc,oldpc2,oldpc3,spsr[mode&15]);
                                        rpclog(":         %08X %08X %08X %08X %08X %08X %08X %08X  %08X %08X %08X %08X\n",armregs[8],armregs[9],armregs[10],armregs[11],armregs[12],armregs[13],armregs[14],armregs[15],opcode,opcode2,opcode3,armregs[16]);
                                if (timetolive)
                                {
                                        timetolive--;
                                        if (!timetolive)
                                        {
                                                output=1;
                                                exit(0);
                                        }
                                }
//                                ins++;
                        }
                        #endif
//                        linecyc--;
//                        inscount++;
//                        ins++;
                }
                inscount+=200;
                rinscount+=200;
/*                iomd.t0c--;
                iomd.t1c--;
                if ((iomd.t0c<0) || (iomd.t1c<0)) updateiomdtimers();*/
                if (kcallback)
                {
                        kcallback--;
                        if (kcallback<=0)
                        {
                                kcallback=0;
                                keycallback();
                        }
                }
                if (mcallback)
                {
                        mcallback-=10;
                        if (mcallback<=0)
                        {
                                mcallback=0;
                                mscallback();
                        }
                }
                if (fdccallback)
                {
                        fdccallback-=10;
                        if (fdccallback<=0)
                        {
                                fdccallback=0;
                                callbackfdc();
                        }
                }
                if (idecallback)
                {
                        idecallback-=10;
//                        if (output) printf("IDE callback now %i\n",idecallback);
                        if (idecallback<=0)
                        {
                                idecallback=0;
                                callbackide();
                        }
                }
                if (motoron)
                {
                        fdci--;
                        if (fdci<=0)
                        {
                                fdci=20000;
                                iomd.stata|=4;
                                updateirqs();
                        }
                }
//                printf("T0 now %04X\n",iomd.t0c);
//                cyc=(oldcyc-cycles);
/*                if (soundbufferfull)
                {
                        updatesoundbuffer();
                }*/
                cycles-=200;
        }
}
#endif
