Notes on RPCemu dynarec :

The makefile does not include the relevant files as of yet, as this is totally experimental.
In order to compile, you must remove arm.c, and include ArmDynarec.c and codegen_x86.c.
ArmDynarecOps.c is included in ArmDynarec.c, and doesn't need to be compiled seperately.

This only works on x86-32 at the moment. An x86-64 port shouldn't be too difficult. Other
ports probably will be.

This hasn't been tested on linux at all.

This hasn't been tested on that many programs. The ones that have been tested (and work) are :

RISC OS 3.7
RISC OS 4.02 (don't enable lazy task swapping if cache is on)
RISC OS 4.39 (don't enable lazy task swapping if cache is on)
!Quake
!FQuake
!Freedoom
!OpenTTD
!FishTank2
!PCengine
MAME
!Freestyle
!Zero
!MetaMorph
!Jan3D
!Icon
!AWViewer
!SICK

You must be in SA110 emulation for this to work. I haven't tested with ARM610, ARM710 or
ARM7500, but I suspect these will crash fairly quickly, due to the difference in CP15 cache
handling.

Compatibility is mostly the same as a real StrongARM RiscPC - ie the stuff that doesn't work
there won't work here. This includes old versions of apps (eg Ovation, SparkFS), old versions
of utilities (eg ROS 3.6 !Configure, as included in the supplied RPCemu disk images) and old
games (ie any unpatched).

In order to disable the dynarec disable the cache (ie *cache 0). This returns compatibility (mostly) to normal, and to a speed only a little slower than previous versions of RPCemu.

The instruction cache currently uses 19 megs. This can most likely be reduced, but you would 
need to pay attention to the hashing function.


This isn't a true dynarec at the moment, it's what would be called a threaded interpreter. It
does generate code blocks, but instead of generating native code, it generates calls to 
handler functions for every opcode. This eliminates instruction fetch and (in many cases)
condition checking. A full dynarec shouldn't be a massive jump from here.

The code blocks are flushed when the StrongARM Icache is flushed. This means that, as on a
real StrongARM, self modifying code won't really work. I did create a version where self
modifying code did work, but the speed was eratic - some programs performed really badly.
Hence the current version doesn't have this in.


The performance increase on my main machine (Athlon X2 4200+) ranges from about 50% (!SICK,
RISC OS in general) to 100% (!Fishtank2). 

Benchmarks noted :

Dhrystone - 140k on Athlon XP 4200+, 133k on Core 2 Duo 1.66ghz
Riscosmark CPU test - 68% of StrongARM speed
!FQuake   - 9 fps average (16fps on real SA)
The highest instruction rate I've seen so far is on Fishtank2, which runs at around 65-70 
MIPS. I've also seen 82 MIPS, but I can't remember on what.


Ideas for optimisations/design flaws:

When the Icache is flushed, all blocks are flushed except those between 3800000 and 3FFFFFF
(ie those in ROM). This probably breaks any operating system other than RISC OS, but since no
other operating systems work I don't consider this much of a problem at the minute.

Blocks always end when the PC could be modified (depending on condition codes). In theory, if
a jump is not taken, then it should be possible to continue the block and put a check in the
generated code for when the jump _is_ taken.
There is one exception in the current recompiler - when a branch occurs but is _not_ taken
when the block is being compiled, the recompiler carries on, and puts in code to jump out if
the branch is taken.

The recompiler doesn't handle small loops very well. It should be possible for backwards 
jumps into locations in the same block to simply jump rather than end the block, and enter it
again. There would need to be some kind of limit though, to prevent hardware polling loops to
circle forever. Maybe get the recompiler to unroll the loop a bit?
An alternative idea is to add some code to the end of a block, that checks if the next block
has already been compiled, and jumps straight to it instead of returning to execx86().

R15 is updated after each instruction except for LDR/STR/LDM/STM instructions where R15 is not
involved. It should be possible to implement lazy updating for data processing instructions,
but every time I've tried I get perculiar errors - presumably an obscure bug somewhere.

Abort checking can be done either at the end of every LDR/STR/LDM/STM instruction, or at the
end of each block (depending on the status of ABORTCHECKING - see rpcemu.h). RISC OS 3.7 works
okay with ABORTCHECKING commented out, but RISC OS 4.02 and 4.39 need it set.

It might be possible to support self modifying code, by keeping a 'page dirty' bit, and
checking it on relevant blocks. If the bit is set, flush every block on the current page. Not
sure what effect this would have on performance, or if there would even be much point - the
StrongARM came out 11 years ago, and no program in that time would/should be using self
modifying code without flushing the cache.
I have now tried this, and the performance is variable - games and demos are mostly okay,
but the desktop plummets from 67 MIPS to 45, and Dhrystone goes from 48ish MIPS to 4 MIPS.
Hence it's not implemented!

Obviously this should become a proper dynarec at some point - eg generate actual code for
each instruction.